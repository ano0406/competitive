#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
using namespace std;
long long MOD = 1e9 + 7;
typedef pair<long long,long long> pii;

int K;
template< typename T >
struct edge {
	int src, to;
	T cost;

	edge(int to, T cost) : src(-1), to(to), cost(cost) {}

	edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}

	edge& operator=(const int& x) {
		to = x;
		return *this;
	}

	operator int() const { return to; }
};

template< typename T >
using Edges = vector< edge< T > >;
template< typename T >
using WeightedGraph = vector< Edges< T > >;
using UnWeightedGraph = vector< vector< int > >;
template< typename T >
using Matrix = vector< vector< T > >;
template< typename T >
vector< T > dijkstra(WeightedGraph< T >& g, int s) {
	const auto INF = numeric_limits< T >::max();
	vector< T > dist(g.size(), INF);

	using Pi = pair< T, int >;
	priority_queue< Pi, vector< Pi >, greater< Pi > > que;
	dist[s] = 0;
	que.emplace(dist[s], s);
	while (!que.empty()) {
		T cost;
		int idx;
		tie(cost, idx) = que.top();
		que.pop();
		if (dist[idx] < cost) continue;
		for (auto& e : g[idx]) {
			auto next_cost = cost + e.cost;
			if (dist[e.to] <= next_cost) continue;
			dist[e.to] = next_cost;
			que.emplace(dist[e.to], e.to);
		}
	}
	return dist;
}

int main() {
	cin >> K;
	WeightedGraph<long long> G(K+1);
	for (int k = 1; k <= K; k++) {
		G[k].push_back({ k,k%K+1,1 });
		G[k].push_back({ k,(10*k - 1) % K + 1,0 });
	}
	auto ans = dijkstra(G, 1);
	cout << ans[K]+1 << endl;
}