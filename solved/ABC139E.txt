#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
using namespace std;
const long long MOD = 1e9+7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
//typedef boost::multiprecision::cpp_int bigint;

ll N;

ll enc(ll a, ll b) {
	if (a >= b)swap(a, b);
	return N * (N - 1) / 2 - (N - a) * (N - a - 1) / 2 + b - a - 1;
}

vector<vector<ll>> edges, edgesinv;

void topologicalVisit(ll n, vector<ll>& check, stack<ll>& q, bool& flag) {
	if (check.at(n) == 1) {
		flag = true;
		return;
	}
	if (check.at(n) == 0) {
		check.at(n) = 1;
		for (auto itr = edges[n].begin(); itr != edges[n].end(); itr++) {
			topologicalVisit(*itr, check, q, flag);
			if (flag)return;
		}
		check[n] = 2;
		q.push(n);
	}
}

int main() {
	cin >> N;
	edges.resize(N * (N - 1) / 2);
	edgesinv.resize(N * (N - 1) / 2);
	for (ll n = 0; n < N; n++) {
		vector<ll> temp(N - 1);
		for (ll e = 0; e < N - 1; e++)cin >> temp[e];
		for (ll e = N - 3; e >= 0; e--) {
			edges[enc(n, temp[e + 1]-1)].push_back(enc(n, temp[e]-1));
			edgesinv[enc(n, temp[e]-1)].push_back(enc(n, temp[e+1]-1));
		}
	}
	vector<ll> check(N * (N - 1),0);   //0初期・1一時的・2恒常的
	vector<ll> topans;   //結果保存用 i -> j  => topans[i] < topans[j]
	stack<ll> qans;
	bool cflag = false;
	for (int i = 0; i < N*(N-1)/2; i++) {
		if (check[i] != 0)continue;
		topologicalVisit(i, check, qans, cflag);
	}
	//cflag == trueだったら木じゃない
	while (!qans.empty()) {
		topans.push_back(qans.top());
		qans.pop();
	}
	if (cflag) {
		cout << -1 << endl;
		return 0;
	}
	vector<ll> DP(N * (N - 1) / 2,0);
	for (ll n : topans) {
		if (edgesinv[n].size() == 0)continue;
		for (ll prev : edgesinv[n]) {
			DP[n] = max(DP[n], DP[prev]);
		}
		DP[n]++;
	}
	ll ans = 0;
	for (ll n = 0; n < DP.size(); n++)ans = max(ans, DP[n]);
	cout << ans+1 << endl;
	return 0;
}