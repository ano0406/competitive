#include <iostream>

#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
using namespace std;

template<class T>
void in(vector<T>& V) {
	for (auto itr = V.begin(); itr != V.end(); itr++)cin >> *itr;
	return;
}

template<class T>
void out(vector<T>& V) {
	for (T& itr : V)cout << itr << endl;
	return;
}

int N, K;
vector<vector<int>> V;
int MOD = 1e9 + 7;

int main() {
	cin >> N >> K;
	V.resize(N);
	for (int n = 0; n < N - 1; n++) {
		int a, b;
		cin >> a >> b;
		V[--a].push_back(--b);
		V[b].push_back(a);
	}
	vector<vector<int>> VV(N,vector<int>());
	queue<pair<int,int>> q;
	q.push(pair<int,int>(0,-1));
	vector<int> parent;
	parent.resize(N);
	long long ans = 1;
	while (!q.empty()) {
		int cur = q.front().first;
		int par = q.front().second;
		q.pop();
		parent[cur] = par;
		for (int c : V[cur]) {
			if (c != par)q.push(pair<int, int>(c, cur));
		}
	}
	q.push(pair<int, int>(0, 0));
	vector<int> check(N, 0);
	while (!q.empty()) {
		int cur = q.front().first;
		q.pop();
		int counter = 0;
		if (parent[cur] != -1) {
			//親は存在する
			if (parent[parent[cur]] != -1)counter += 2;//祖父まで含めた数
			else counter += 1;
			//うちチェック済みを除く
			counter += check[parent[cur]];
			check[parent[cur]]++;
		}
		ans *= (K-counter);
		ans %= MOD;
		for (int c : V[cur]) {
			if (c != parent[cur])q.push(pair<int, int>(c, 0));
		}
	}
	cout << ans << endl;
	return 0;
}
