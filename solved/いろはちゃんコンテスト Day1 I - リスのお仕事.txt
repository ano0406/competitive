#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>
#include <list>
#include <bitset>

//< in.txt > out.txt
using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 1e9 + 7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
typedef vector<ll> VLL;
typedef vector<VLL> VVLL;
//typedef boost::multiprecision::cpp_int bigint;

ll N, M, K;
struct edge0 {
	ll s, t;
	ll c;
};
vector<edge0> edges0;
vector<pll> points;
vector<vector<pll>> edges;
VLL DP;

ll find(pll a) {
	ll s = 0, e = points.size();
	while (e - s > 1) {
		ll m = (e + s) / 2;
		bool res = false;
		if (points[m].first != a.first)res = (points[m].first < a.first);
		else res = (points[m].second <= a.second);
		if (res)s = m;
		else e = m;
	}
	return s;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	cin >> N >> M >> K;
	edges0.resize(M);
	set<pll> temp;
	for (ll m = 0; m < M; m++) {
		edge0& e = edges0[m];
		cin >> e.s >> e.t >> e.c;
		temp.insert(pll(e.s, e.c));
		temp.insert(pll(e.t, e.c));
	}
	points.reserve(temp.size());
	for (pll itr : temp) {
		points.push_back(itr);
	}
	points.push_back(pll(0, 0));
	sort(points.begin(), points.end(), [](pll a, pll b) {
		if (a.first != b.first)return a.first < b.first;
		return a.second < b.second;
	});
	edges.resize(points.size());
	for (ll m = 0; m < M; m++) {
		edge0& e = edges0[m];
		ll ind0 = find(pll(e.s, e.c));
		ll ind1 = find(pll(e.t, e.c));
		edges[ind0].push_back(pll(ind1, 0));
		edges[ind1].push_back(pll(ind0, 0));
	}
	for (ll n = 1; n < points.size(); n++) {
		if (points[n].first != 1)break;
		edges[0].push_back(pll(n, 0));
	}
	ll prev = 1;
	for (ll n = 2; n < points.size(); n++) {
		if (points[prev].first == points[n].first)continue;
		for (ll s = prev; s < n; s++) {
			for (ll t = s + 1; t < n; t++) {
				edges[s].push_back(pll(t, 1));
				edges[t].push_back(pll(s, 1));
			}
		}
		prev = n;
	}
	for (ll s = prev; s < points.size(); s++) {
		for (ll t = s + 1; t < points.size(); t++) {
			edges[s].push_back(pll(t, 1));
			edges[t].push_back(pll(s, 1));
		}
	}
	DP.resize(points.size(), LLONG_MAX);
	DP[0] = 0;
	deque<pll> deq;
	deq.push_back(pll(0, 0));
	while (!deq.empty()) {
		ll cp = deq.front().first;
		ll co = deq.front().second;
		deq.pop_front();
		if (DP[cp] < co)continue;
		for (pll p : edges[cp]) {
			if (DP[p.first] <= co + p.second)continue;
			if (p.second == 0) {
				DP[p.first] = co;
				deq.push_front(pll(p.first,co));
			}
			else {
				DP[p.first] = co + 1;
				deq.push_back(pll(p.first, co + 1));
			}
		}
	}
	ll ans = LLONG_MAX;
	for (ll m = 0; m < points.size(); m++) {
		if (points[m].first != N)continue;
		ans = min(ans, DP[m]);
	}
	if (ans == LLONG_MAX)cout << -1 << "\n";
	else cout << (ans+1) * K << "\n";
	return 0;
}