#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
using namespace std;

vector<vector<pair<long long,int>>> edges,edgesinv;
vector<long long> Wmin,Xmin,Ymin,Zmin;
vector<long long> Allmin;

//edgesに従いsから、SからTの範囲で最短距離を求める
void dijkstra(vector<long long>& vec, int s,int S,int T) {
	vec.resize(T+1,LLONG_MAX);
	priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>> > q;
	q.push(pair<long long, int>(0, s));
	while (!q.empty()) {
		int cur = q.top().second;
		long long cd = q.top().first;
		q.pop();
		if (vec[cur] <= cd)continue;
		vec[cur] = cd;
		for (auto itr = edges[cur].begin(); itr != edges[cur].end(); itr++) {
			q.push(pair<long long, int>(cd+itr->first,itr->second));
		}
	}
}

//edgesinvに従いsから、SからTの範囲で最短距離を求める
void dijkstrainv(vector<long long>& vec, int s, int S, int T) {
	vec.resize(T + 1,LLONG_MAX);
	priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> q;
	q.push(pair<long long, int>(0, s));
	while (!q.empty()) {
		int cur = q.top().second;
		long long cd = q.top().first;
		q.pop();
		if (vec[cur] <= cd)continue;
		vec[cur] = cd;
		for (auto itr = edgesinv[cur].begin(); itr != edgesinv[cur].end(); itr++) {
			q.push(pair<long long, int>(cd+itr->first,itr->second));
		}
	}
}


void solve() {
	int N, M, W, X, Y,Z;
	cin >> N >> M >> W >> X >> Y >> Z;
	int S = min(W, Y);
	int T = max(X, Z);
	edges.clear();
	edges.resize(T + 2);
	edgesinv.clear();
	edgesinv.resize(T + 1);
	for (int m = 0; m < M; m++) {
		int c, s, t;
		cin >> c >> s >> t;
		if (s < S || T < s)continue;
		if (t < S || T < t)continue;
		edges[s].push_back(pair<long long, int>(c, t));
		edgesinv[t].push_back(pair<long long, int>(c, s));
	}
	Wmin.clear(); Ymin.clear(); Xmin.clear(); Zmin.clear();
	dijkstra(Wmin, W, S, T);
	dijkstra(Ymin, Y, S, T);
	dijkstrainv(Xmin, X, S, T);
	dijkstrainv(Zmin, Z, S, T);
	long long ans1;
	if (Wmin[X] == LLONG_MAX || Ymin[Z] == LLONG_MAX)ans1 = LLONG_MAX;
	else ans1 = Wmin[X] + Ymin[Z];
	//頂点追加
	for (int n = S - 1; n <= T; n++) {
		if (Wmin[n] != LLONG_MAX && Ymin[n] != LLONG_MAX) {
			edges[S - 1].push_back(pair<long long, int>(Wmin[n] + Ymin[n], n));
		}
		if (Xmin[n] != LLONG_MAX && Zmin[n] != LLONG_MAX) {
			edges[n].push_back(pair<long long, int>(Xmin[n] + Zmin[n], T + 1));
		}
	}
	Allmin.clear();
	dijkstra(Allmin, S - 1, S - 1, T + 1);
	long long ans2 = Allmin[T + 1];
	if (min(ans1, ans2) == LLONG_MAX)cout << "Impossible" << endl;
	else cout << min(ans1, ans2) << endl;
	return;
}

//////////////////////////////
//////////////////////////////

int main() {
#ifdef DEBUGTIME
	for (int time = 0; time < DEBUGTIME; time++) {
		solve();
		cout << "####################" << endl;
	}
#else
	solve();
#endif
	return 0;
}
