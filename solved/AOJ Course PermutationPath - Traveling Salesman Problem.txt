void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
using namespace std;

int V, E;
vector<vector<int>> G;
vector<int> order;
vector<vector<vector<int>>> DP;

void solve() {
	cin >> V >> E;
	G.resize(V);
	for (int v = 0; v < V; v++)G[v].resize(V,-1);
	for (int e = 0; e < E; e++) {
		int s, t, d;
		cin >> s >> t >> d;
		G[s][t] = d;
	}
	DP.resize(1 << V);
	for (int code = 0; code < (1 << V); code++) {
		DP[code].resize(V);
		for (int o = 0; o < V; o++)DP[code][o].resize(V, -1);
	}
	order.resize(1 << V);
	for (int n = 0; n < (1 << V); n++) order[n] = n;
	sort(order.begin(), order.end(), [](int a, int b) {
		unsigned int counta = a;
		counta = (counta & 0x55555555) + ((counta & 0xAAAAAAAA) >> 1);
		counta = (counta & 0x33333333) + ((counta & 0xCCCCCCCC) >> 2);
		counta = (counta & 0x0F0F0F0F) + ((counta & 0xF0F0F0F0) >> 4);
		counta = (counta & 0x00FF00FF) + ((counta & 0xFF00FF00) >> 8);
		counta = (counta & 0x0000FFFF) + ((counta & 0xFFFF0000) >> 16);
		unsigned int countb = b;
		countb = (countb & 0x55555555) + ((countb & 0xAAAAAAAA) >> 1);
		countb = (countb & 0x33333333) + ((countb & 0xCCCCCCCC) >> 2);
		countb = (countb & 0x0F0F0F0F) + ((countb & 0xF0F0F0F0) >> 4);
		countb = (countb & 0x00FF00FF) + ((countb & 0xFF00FF00) >> 8);
		countb = (countb & 0x0000FFFF) + ((countb & 0xFFFF0000) >> 16);
		return counta < countb;
	});
	for (int v = 0; v < V; v++)DP[1 << v][v][v] = 0;
	for (auto itr = order.begin()+V+1; itr != order.end(); itr++) {
		int code0 = *itr;
		for (int origin = 0; origin < V; origin++) {
			if ((code0 & (1 << origin)) == 0)continue;
			for (int cur = 0; cur < V; cur++) {
				if ((code0 & (1 << cur)) == 0)continue;
				int code = code0 - (1 << cur);
				for (int prev = 0; prev < V; prev++) {
					if ((code & (1 << prev)) == 0)continue;
					if (DP[code][origin][prev] == -1)continue;
					if (G[prev][cur] == -1)continue;
					if (DP[code0][origin][cur] == -1 || DP[code0][origin][cur] > DP[code][origin][prev] + G[prev][cur]) {
						DP[code0][origin][cur] = DP[code][origin][prev] + G[prev][cur];
					}
				}
			}
		}
	}
	int ans = INT_MAX;
	for (int v = 0; v < V; v++) {
		for (int origin = 0; origin < V; origin++) {
			if (v == origin)continue;
			if (DP[(1 << V) - 1][origin][v] == -1)continue;
			if (G[v][origin] == -1)continue;
			ans = min(ans, DP[(1 << V) - 1][origin][v] + G[v][origin]);
		}
	}
	if (ans == INT_MAX)cout << -1 << endl;
	else cout << ans << endl;
	return;
}