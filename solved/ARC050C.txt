#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
using namespace std;

long long A, B, M;

long long mypow(long long base, long long p) {
	if (p == 0)return 1;
	long long temp = pow(base, p/2);
	temp = (temp * temp) % M;
	if ((p & 1))temp = (temp * base) % M;
	return temp;
}

template< class T >
class Matrix {
public:
	vector< vector< T > > A;

	Matrix() {}

	Matrix(size_t n, size_t m) : A(n, vector< T >(m, 0)) {}

	Matrix(size_t n) : A(n, vector< T >(n, 0)) {};

	size_t height() const {
		return (A.size());
	}

	size_t width() const {
		return (A[0].size());
	}

	inline const vector< T >& operator[](int k) const {
		return (A.at(k));
	}

	inline vector< T >& operator[](int k) {
		return (A.at(k));
	}

	static Matrix I(size_t n) {
		Matrix mat(n);
		for (int i = 0; i < n; i++) mat[i][i] = 1;
		return (mat);
	}

	Matrix& operator+=(const Matrix& B) {
		size_t n = height(), m = width();
		assert(n == B.height() && m == B.width());
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				(*this)[i][j] += B[i][j];
		return (*this);
	}

	Matrix& operator-=(const Matrix& B) {
		size_t n = height(), m = width();
		assert(n == B.height() && m == B.width());
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				(*this)[i][j] -= B[i][j];
		return (*this);
	}

	Matrix& operator*=(const Matrix& B) {
		size_t n = height(), m = B.width(), p = width();
		assert(p == B.height());
		vector< vector< T > > C(n, vector< T >(m, 0));
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				for (int k = 0; k < p; k++)
					C[i][j] = (C[i][j] + (*this)[i][k] * B[k][j]);
		A.swap(C);
		return (*this);
	}

	Matrix& operator^=(long long k) {
		Matrix B = Matrix::I(height());
		while (k > 0) {
			if (k & 1) B *= *this;
			*this *= *this;
			k >>= 1LL;
		}
		A.swap(B.A);
		return (*this);
	}

	Matrix operator+(const Matrix& B) const {
		return (Matrix(*this) += B);
	}

	Matrix operator-(const Matrix& B) const {
		return (Matrix(*this) -= B);
	}

	Matrix operator*(const Matrix& B) const {
		return (Matrix(*this) *= B);
	}

	Matrix operator^(const long long k) const {
		return (Matrix(*this) ^= k);
	}
};

long long GCD(long long a, long long b) {
	if (a%b == 0)return b;
	else return GCD(b, a % b);
}

Matrix<long long> pow(Matrix<long long> a, long long p) {
	if (p == 0) {
		Matrix<long long> I(2, 2);
		I[0][0] = 1;
		I[1][1] = 1;
		return I;
	}
	else if (p == 1)return a;
	Matrix<long long> ans(2,2);
	ans = pow(a, p / 2);
	ans = ans * ans;
	for (int w = 0; w < 2; w++) {
		for (int h = 0; h < 2; h++) {
			ans[h][w] %= M;
		}
	}
	if (p & 1) {
		ans = ans * a;
		for (int w = 0; w < 2; w++) {
			for (int h = 0; h < 2; h++) {
				ans[h][w] %= M;
			}
		}
	}
	return ans;
}

int main() {
	long long a, b;
	cin >> a >> b >> M;
	A = max(a, b), B = min(a, b);
	long long G = GCD(A, B);
	Matrix<long long> ansa(2,2);
	ansa[0][0] = 10 % M;
	ansa[0][1] = 1;
	ansa[1][0] = 0;
	ansa[1][1] = 1;
	ansa = pow(ansa, A);
	long long k = mypow(10, G);
	Matrix<long long> ansb(2, 2);
	ansb[0][0] = k;
	ansb[0][1] = 1;
	ansb[1][0] = 0;
	ansb[1][1] = 1;
	ansb = pow(ansb, B / G);
	long long ans = (ansa[0][1] * ansb[0][1]) % M;
	cout << ans << endl;
	return 0;
}