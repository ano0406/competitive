#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>
#include <list>

//< in.txt > out.txt
using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 1e9 + 7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
typedef vector<ll> VLL;
typedef vector<VLL> VVLL;
//typedef boost::multiprecision::cpp_int bigint;

ll N, M;
vector<pdd> mons;   //魔力、体力
vector<pdd> help;

bool judge(ld K) {
	vector<pdl> V1(N);
	for (ll n = 0; n < N; n++) {
		V1[n] = pdl(mons[n].first - mons[n].second * K, 0);
	}
	vector<pdl> V2(M);
	for (ll m = 0; m < M; m++) {
		V2[m] = pdl(help[m].first - help[m].second * K, 1);
	}
	sort(V1.begin(), V1.end(), [](pdl a, pdl b) {
		return a.first > b.first;
	});
	sort(V2.begin(), V2.end(), [](pdl a, pdl b) {
		return a.first > b.first;
	});
	ld ans = 0;
	if (V2[0].first >= V1[4].first) {
		ans = V1[0].first + V1[1].first + V1[2].first + V1[3].first + V2[0].first;
	}
	else {
		ans = V1[0].first + V1[1].first + V1[2].first + V1[3].first + V1[4].first;
	}
	if (ans >= 0)return true;
	else return false;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	cin >> N >> M;
	mons.resize(N);
	help.resize(M);
	for (ll n = 0; n < N; n++) {
		cin >> mons[n].second >> mons[n].first;
	}
	for (ll m = 0; m < M; m++) {
		cin >> help[m].second >> help[m].first;
	}
	ld s = 0, e = 1e6;
	for (ll t = 0; t < 200; t++) {
		ld m = (e + s) / 2;
		if (judge(m))s = m;
		else e = m;
	}
	cout <<setprecision(12) << s << "\n";
	return 0;
}
