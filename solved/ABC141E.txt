#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>
#include <list>
#include <bitset>

//< in.txt > out.txt
using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 1e9 + 7;
typedef long long ll;
typedef long long LL;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
typedef vector<ll> VLL;
typedef vector<VLL> VVLL;
typedef unsigned long long ULL;
//typedef boost::multiprecision::cpp_int bigint;

typedef unsigned long long HASH;

class RollingHash {
public:
	static const ULL HMOD = (1ULL << 61) - 1;
	static const ULL MASK30 = (1ULL << 30) - 1;
	static const ULL MASK31 = (1ULL << 31) - 1;
	static ULL base;
	static const ULL POS = HMOD * ((1ULL << 3) - 1);
	static vector<ULL> powmemo;
	vector<HASH> hash;   //部分列[0,n)のハッシュを持つ
	RollingHash(vector<LL>& S) {
		if (base == 0) {
			random_device rnd;
			mt19937 mt(rnd());
			uniform_int_distribution<ULL> rand(129, HMOD - 1);
			RollingHash::base = rand(mt);
			powmemo.resize(500000, 1);
			for (LL n = 1; n < 500000; n++) {
				powmemo[n] = mod(Mul(powmemo[n - 1], base));
			}
		}
		hash.resize(S.size() + 1);
		hash[0] = 0;
		for (ll n = 1; n <= S.size(); n++) {
			hash[n] = mod(Mul(hash[n - 1], base) + S[n - 1]);
		}
	}
	//部分列[a,b)のハッシュ
	HASH get(LL a, LL b) {
		return mod(hash[b] + POS - Mul(hash[a], powmemo[b - a]));
	}
	//部分列配列への保存なしに変換
	HASH conv(vector<LL>& S) {
		HASH ans = 0;
		for (ll n = 0; n < S.size(); n++) {
			ans = mod(Mul(ans, base) + S[n]);
		}
		return ans;
	}
	static HASH Mul(HASH a, HASH b) {
		HASH au = a >> 31;
		HASH ad = a & MASK31;
		HASH bu = b >> 31;
		HASH bd = b & MASK31;
		HASH midd = au * bd + ad * bu;
		HASH midu = midd >> 30;
		midd = midd & MASK30;
		return ((au * bu) << 1) + ad * bd + (midd << 31) + midu;
	}
	static HASH mod(HASH val) {
		val = (val & HMOD) + (val >> 61);
		if (val >= HMOD)val -= HMOD;
		return val;
	}
};
ULL RollingHash::base = 0;
vector<ULL> RollingHash::powmemo = vector<ULL>();

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	ll N;
	string S;
	cin >> N >> S;
	vector<LL> VS(N);
	for (ll n = 0; n < N; n++) {
		VS[n] = S[n] - 'a';
	}
	ll ans = 0;
	RollingHash rh(VS);
	for (ll i = 0; i < N; i++) {
		for (ll j = i + 1; j < N; j++) {
			ll s = 0, e = min(j - i, N - j) + 1;
			while (e - s > 1) {
				ll m = (e + s) / 2;
				HASH ha = rh.get(i, i + m);
				HASH hb = rh.get(j, j + m);
				if (ha == hb)s = m;
				else e = m;
			}
			ans = max(ans, s);
		}
	}
	cout << ans << "\n";
	return 0;
}
