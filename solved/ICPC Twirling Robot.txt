void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
using namespace std;

struct smove {
	int x, y;
	int cost;
	int d;
};

bool isin(smove m, int w, int h) {
	if (m.x >= 0 && m.x < w && m.y >= 0 && m.y < h)return true;
	return false;
}

smove operator+(smove a, smove b) {
	return { a.x + b.x,a.y + b.y,a.cost,a.d };
}

void solve() {
	while (true) {
		int W, H;
		cin >> W >> H;
		if (W == 0 && H == 0)return;
		vector<vector<int>> command;
		command.resize(W);
		for (int x = 0; x < W; x++)command[x].resize(H);
		for (int y = 0; y < H; y++) {
			for (int x = 0; x < W; x++)cin >> command[x][y];
		}
		vector<int> cost;
		cost.resize(4);
		for (int i = 0; i < 4; i++)cin >> cost[i];
		vector<smove> commove;
		commove.push_back({ 0,-1,cost[0],0 });
		commove.push_back({ 1,0,cost[1],1 });
		commove.push_back({ 0,1,cost[2],2 });
		commove.push_back({ -1,0,cost[3],3 });
		auto comp = [](smove a, smove b) {
			return a.cost > b.cost;
		};
		priority_queue<smove,vector<smove>,decltype(comp)> q(comp);
		vector<vector<vector<int>>> ans;
		ans.resize(W);
		for (int x = 0; x < W; x++)ans[x].resize(H);
		for (int x = 0; x < W; x++) {
			for (int y = 0; y < H; y++)ans[x][y].resize(4, INT_MAX);
		}
		q.push({ 0,0,0,1 });
		while (!q.empty()) {
			smove curmove = q.top();
			q.pop();
			if (ans[curmove.x][curmove.y][curmove.d] <= curmove.cost)continue;
			ans[curmove.x][curmove.y][curmove.d] = curmove.cost;
			for (int i = 0; i < 4; i++) {   //各コマンド
				smove nextmove = { curmove.x,curmove.y,0,0 };
				nextmove.d = (curmove.d + i) % 4;
				nextmove.x += commove[nextmove.d].x;
				nextmove.y += commove[nextmove.d].y;
				if (!isin(nextmove, W, H))
					continue;
				nextmove.cost = curmove.cost;
				if(i != command[curmove.x][curmove.y])nextmove.cost += commove[i].cost;
				q.push(nextmove);
			}
		}
		cout << 
			min({ ans[W - 1][H - 1][0],ans[W - 1][H - 1][1],ans[W - 1][H - 1][2],ans[W - 1][H - 1][3] })
			<< endl;
	}
}