#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
using namespace std;
long long MOD = 1e9 + 7;

vector<vector<int>> black,white;
int N, K;

int ret(vector<vector<int>>& vec,int rx, int ry, int lx, int ly) {
	if (rx == -1 || ry == -1)return 0;
	int temp = vec[rx][ry];
	if (ly >= 1)temp -= vec[rx][ly-1];
	if (lx >= 1)temp -= vec[lx - 1][ry];
	if (lx >= 1 && ly >= 1)temp += vec[lx - 1][ly - 1];
	return temp;
}

int main() {
	cin >> N >> K;
	black.resize(2 * K, vector<int>(2 * K, 0));
	white.resize(2 * K, vector<int>(2 * K, 0));
	for (int n = 0; n < N; n++) {
		int x, y;
		string c;
		cin >> x >> y >> c;
		if (c == string("B")) black[(x % (2 * K) + 2 * K) % (2 * K)][(y % (2 * K) + 2 * K) % (2 * K)]++;
		else white[(x % (2 * K) + 2 * K) % (2 * K)][(y % (2 * K) + 2 * K) % (2 * K)]++;
	}
	for (int x = 0; x < 2 * K; x++) {
		for (int y = 0; y < 2 * K; y++) {
			if (x - 1 >= 0 && y - 1 >= 0) {
				black[x][y] -= black[x - 1][y - 1];
				white[x][y] -= white[x - 1][y - 1];
			}
			if (x - 1 >= 0) {
				black[x][y] += black[x - 1][y];
				white[x][y] += white[x - 1][y];
			}
			if (y - 1 >= 0) {
				black[x][y] += black[x][y - 1];
				white[x][y] += white[x][y - 1];
			}
		}
	}
	int ans = 0;
	for (int lx = 0; lx < K; lx++) {
		for (int ly = 0; ly < K; ly++) {
			//[lx,rx)*[ly,ry)が黒のパターン
			int rx = lx + K-1;
			int ry = ly + K-1;
			int bl = ret(black, rx, ry, lx, ly)
				+ ret(black, lx - 1, ly - 1, 0, 0)
				+ ret(black, lx - 1, 2 * K - 1, 0, ry + 1)
				+ ret(black, 2 * K - 1, 2 * K - 1, rx + 1, ry + 1)
				+ ret(black, 2 * K - 1, ly - 1, rx + 1, 0);
			int wh =
				ret(white, rx,ly-1,lx,0)
				+ ret(white, 2*K-1,ry,rx+1,ly)
				+ ret(white, rx,2*K-1,lx,ry+1)
				+ ret(white, lx-1,ry,0,ly);
			ans = max(ans, bl + wh);
		}
	}
	for (int lx = 0; lx < K; lx++) {
		for (int ly = 0; ly < K; ly++) {
			//[lx,rx)*[ly,ry)が白のパターン
			int rx = lx + K-1;
			int ry = ly + K-1;
			int bl = ret(white, rx, ry, lx, ly)
				+ ret(white, lx - 1, ly - 1, 0, 0)
				+ ret(white, lx - 1, 2 * K - 1, 0, ry + 1)
				+ ret(white, 2 * K - 1, 2 * K - 1, rx + 1, ry + 1)
				+ ret(white, 2 * K - 1, ly - 1, rx + 1, 0);
			int wh =
				ret(black, rx, ly - 1, lx, 0)
				+ ret(black, 2 * K - 1, ry, rx + 1, ly)
				+ ret(black, rx, 2 * K - 1, lx, ry + 1)
				+ ret(black, lx - 1, ry, 0, ly);
			ans = max(ans, bl + wh);
		}
	}
	cout << ans << endl;
	return 0;
}
