void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <functional>
#include <map>
#include <string>
#include <boost/multiprecision/cpp_int.hpp>
#include <limits.h>
#include <iomanip>
#include <stack>

using namespace std;
using namespace boost::multiprecision;

//重みなしのグラフのクラス
class graph {
public:
	int N;
	vector<set<int>>* E;
	graph(int);
	graph();
	void construct(int);
	~graph();
	void addEdge(int, int);
	void removeEdge(int, int);
	bool isConnected(int, int);
};

graph::graph(int n) {
	construct(n);
}

graph::graph() {
	N = 0;
}

graph::~graph() {
	delete E;
}

void graph::construct(int n) {
	N = n;
	E = new vector<set<int>>;
	E->resize(N);
}

void graph::addEdge(int a, int b) {
	E->at(a).insert(b);
}

void graph::removeEdge(int a, int b) {
	auto itr = E->at(a).find(b);
	if (itr != E->at(a).end())E->at(a).erase(itr);
}

bool graph::isConnected(int a, int b) {
	return (E->at(a).find(b) != E->at(a).end());
}

set<int> s;   //追加済み頂点集合
stack<int> st;   //求める順に追加していく
queue<int> q;
long long dpf[100000], dpg[100000];
long long MOD = 1000000000 + 7;
int N;
graph G;

void solve() {
	cin >> N;
	G.construct(N);
	for (int n = 0; n < N-1; n++) {
		int a, b;
		cin >> a >> b;
		a--; b--;
		G.addEdge(a, b);
		G.addEdge(b, a);
	}
	q.push(N - 1);
	while (!q.empty()) {
		int e = q.front();
		q.pop();
		s.insert(e);
		st.push(e);
		for (auto itr = G.E->at(e).begin(); itr != G.E->at(e).end(); itr++) {
			if (s.find(*itr) != s.end())continue;
			q.push(*itr);
		}
	}
	for (int n = 0; n < N; n++) {
		dpf[n] = -1;
		dpg[n] = -1;   //未決定
	}
	while (!st.empty()) {
		int e = st.top();
		st.pop();
		long long f = 1, g = 1;
		bool flag = false;
		for (auto itr = G.E->at(e).begin(); itr != G.E->at(e).end(); itr++) {
			if (dpf[*itr] == -1)continue;
			flag = true;
			f *= dpf[*itr];
			f %= MOD;
			g *= dpg[*itr];
			g %= MOD;
		}
		if (!flag) {
			dpg[e] = 1;
			dpf[e] = 2;
		}
		else {
			dpg[e] = f;
			dpf[e] = dpg[e] + g;
			dpf[e] %= MOD;
		}
	}
	cout << dpf[N - 1] << endl;
	return;
}