void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <functional>
#include <map>
#include <string>
#include <boost/multiprecision/cpp_int.hpp>
#include <limits.h>
#include <iomanip>
#include <stack>

using namespace std;
using namespace boost::multiprecision;

//重みなしのグラフのクラス
class graph {
public:
	int N;
	vector<set<int>>* E;
	graph(int);
	graph();
	void construct(int);
	~graph();
	void addEdge(int, int);
	void removeEdge(int, int);
	bool isConnected(int, int);
};

graph::graph(int n) {
	construct(n);
}

graph::graph() {
	N = 0;
}

graph::~graph() {
	delete E;
}

void graph::construct(int n) {
	N = n;
	E = new vector<set<int>>;
	E->resize(N);
}

void graph::addEdge(int a, int b) {
	E->at(a).insert(b);
}

void graph::removeEdge(int a, int b) {
	auto itr = E->at(a).find(b);
	if (itr != E->at(a).end())E->at(a).erase(itr);
}

bool graph::isConnected(int a, int b) {
	return (E->at(a).find(b) != E->at(a).end());
}

void topologicalVisit(graph& g0, int n, vector<char>& check, stack<int>& q, bool& flag) {
	if (check.at(n) == 1) {
		flag = true;
		return;
	}
	if (check.at(n) == 0) {
		check.at(n) = 1;
		for (auto itr = g0.E->at(n).begin(); itr != g0.E->at(n).end(); itr++) {
			topologicalVisit(g0, *itr, check, q, flag);
			if (flag)return;
		}
		check[n] = 2;
		q.push(n);
	}
}

//与えられたグラフにトポロジカル順序?をつけたい
//(i->j => n(i) < n(j))
//グラフ、結果保存用空vector 木か木じゃないか返す
bool topologicalSort(graph& g0, vector<int>& deck) {
	vector<char>* check = new vector<char>;   //初期->0 一時的->1 恒久的-> 2
	check->resize(g0.N);
	for (int i = 0; i < g0.N; i++)check->at(i) = 0;

	stack<int>* qans = new stack<int>;
	bool cflag = false;
	for (int i = 0; i < g0.N; i++) {
		if (check->at(i) != 0)continue;
		topologicalVisit(g0, i, *check, *qans, cflag);
	}
	if (cflag)return false;
	while (!qans->empty()) {
		deck.push_back(qans->top());
		qans->pop();
	}
	delete qans;
	delete check;
	return true;
}

int N, M;
vector<int> top;
vector<set<int>> tree;
vector<int> invect;
vector<bool> dp;

void solve() {
	cin >> N >> M;
	graph G(N);
	invect.resize(N);
	dp.resize(N);
	tree.resize(N);
	for (int n = 0; n < N; n++)invect[n] = 0;
	for (int m = 0; m < M; m++) {
		int a, b;
		cin >> a >> b;
		a--; b--;
		G.addEdge(a, b);
		invect[b]++;
	}
	topologicalSort(G, top);
	for (int i = 0; i < N; i++) {
		int cur = top[i];
		for (auto itr = G.E->at(cur).begin(); itr != G.E->at(cur).end(); itr++) {
			invect[*itr]--;
			if (invect[*itr] == 0)tree[cur].insert(*itr);
		}
	}
	bool flag = false;
	for (int n = N - 1; n >= 0; n--) {
		int cur = top[n];
		dp[cur] = false;
		if (tree[cur].size() >= 2) {
			flag = true;
			break;
		}
	}
	for (int n = 0; n < N; n++)cout << top[n]+1 << endl;
	cout << (flag ? 1 : 0) << endl;
	return;
}