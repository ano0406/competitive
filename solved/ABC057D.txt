#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
using namespace std;

long long N,A,B;
vector<long long> V;
vector<long long> res;
vector<vector<long long>> C;

int main() {
	C.resize(51);
	C[0].resize(1);
	C[0][0] = 1;
	C[1].resize(2);
	C[1][0] = 1;
	C[1][1] = 1;
	for (int n = 2; n <= 50; n++) {
		C[n].resize(n + 1);
		C[n][0] = 1;
		for (int k = 1; k <= n - 1; k++)C[n][k] = C[n - 1][k - 1] + C[n - 1][k];
		C[n][n] = 1;
	}
	cin >> N >> A >> B;
	V.resize(N);
	for (int n = 0; n < N; n++)cin >> V[n];
	sort(V.begin(), V.end());
	res.resize(N+1);
	//とりあえず平均最大を求める
	long long avmaxsum = 0;
	long long avmaxn = 0;
	for (int n = A; n <= B; n++) {
		long long sumtemp = 0;
		for (int l = N - 1; l >= N - n; l--)sumtemp += V[l];
		if (avmaxsum * n <= sumtemp * avmaxn) {
			avmaxsum = sumtemp;
			avmaxn = n;
		}
		res[n] = sumtemp;
	}
	long long ans = 0;
	//nのうち、平均最大となるものだけ考える
	for (int n = A; n <= B; n++) {
		if (res[n] * avmaxn != avmaxsum * n)continue;
		//V[N-n]下端
		int s = -1, e = N;
		while (e - s > 1) {
			int m = (e + s) / 2;
			if (V[m] >= V[N - n])e = m;
			else s = m;
		}
		int down = e;
		s = -1, e = N;
		while (e - s > 1) {
			int m = (e + s) / 2;
			if (V[m] > V[N - n])e = m;
			else s = m;
		}
		int up = e;
		//V[N-n]と等しい値を何個取るか
		int vn = s - (N - n) + 1;
		//(up-down)Cvn
		ans += C[up - down][vn];
	}
	cout << setprecision(24) << (long double)avmaxsum / avmaxn << endl;
	cout << ans << endl;
	return 0;
}