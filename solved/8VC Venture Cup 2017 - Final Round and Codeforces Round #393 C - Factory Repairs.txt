#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
using namespace std;
 
long long N, K, A, B, Q,RN;
vector<long long> segA, segB;
 
void addAA(int k) {
	if (k == 0)return;
	segA[k] = segA[2 * k] + segA[2 * k + 1];
	addAA(k / 2);
}
 
//0-index
void addA(int d, long long a) {
	segA[d + RN] += a;
	int k = (d + RN) / 2;
	segA[k] = min(segA[2 * k], A) + min(segA[2 * k + 1], A);
	addAA(k / 2);
}
 
void addBB(int k) {
	if (k == 0)return;
	segB[k] = segB[2 * k] + segB[2 * k + 1];
	addBB(k / 2);
}
 
//0-index
void addB(int d, long long a) {
	segB[d + RN] += a;
	int k = (d + RN) / 2;
	segB[k] = min(segB[2 * k], B) + min(segB[2 * k + 1],B);
	addBB(k / 2);
}
 
long long getA(int a, int b, int k = 1, int l = 0, int r = RN - 1) {
	if (b < l || r < a)return 0;
	if (k >= RN)return min(segA[k], A);
	if (a <= l && r <= b)return segA[k];
	return getA(a, b, 2 * k, l, (l + r) / 2) + getA(a, b, 2 * k + 1, (l + r) / 2 + 1, r);
}
 
long long getB(int a, int b, int k = 1, int l = 0, int r = RN - 1) {
	if (b < l || r < a)return 0;
	if (k >= RN)return min(segB[k], B);
	if (a <= l && r <= b)return segB[k];
	return getB(a, b, 2 * k, l, (l + r) / 2) + getB(a, b, 2 * k + 1, (l + r) / 2 + 1, r);
}
 
int main() {
	cin >> N >> K >> A >> B >> Q;
	if (N == 1)N++;
	RN = 1;
	while (RN < N)RN *= 2;
	segA.resize(2 * RN,0);
	segB.resize(2 * RN,0);
	for (int q = 0; q < Q; q++) {
		int type;
		cin >> type;
		if (type == 1) {
			long long d, a;
			cin >> d >> a;
			addA(--d, a);
			addB(d, a);
		}
		else {
			int p;
			cin >> p;
			long long ans = 0;
			p--;
			if (p != 0)ans += getB(0, p - 1);
			if (p + K <= RN - 1)ans += getA(p + K, RN - 1);
			cout << ans << endl;
		}
	}
	return 0;
}
