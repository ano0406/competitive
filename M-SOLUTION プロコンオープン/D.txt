void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <functional>
#include <map>
#include <string>
#include <boost/multiprecision/cpp_int.hpp>
#include <limits.h>
#include <iomanip>
#include <stack>

using namespace std;
using namespace boost::multiprecision;
typedef pair<int, int> pii;

class segmentTreeElement {
public:
	pii ele;
	segmentTreeElement(pii a) :ele(a) {};
	segmentTreeElement() :ele(pii(INT_MAX,0)) {};
};

segmentTreeElement operator*(segmentTreeElement& a, segmentTreeElement& b) {
	if (a.ele.first < b.ele.first)return a;
	else return b;
}

class segTree {
public:
	long long N;   //中身のある要素数
	long long RN;   //2の累乗数にするために合わせた、ゴミデータ含めた要素数
	vector<segmentTreeElement>* array;
	//コンストラクタ:要素数、初期化用の数
	segTree(long long n) {
		N = n;
		RN = 1;
		while (RN < N)RN *= 2;
		array = new vector<segmentTreeElement>;
		array->resize(2 * RN - 1, segmentTreeElement());
	}
	~segTree() {
		delete array;
	}
	void set(int n, segmentTreeElement t) {   //n番目の要素にtを設定
		n = RN + n - 1;
		array->at(n) = t;
		while (n > 0) {
			n = (n - 1) / 2;
			array->at(n) = array->at(2 * n + 1)*array->at(2 * n + 2);
		}
	}
	inline segmentTreeElement& operator[](int a) {
		return array->at(RN + a - 1);
	}
	inline segmentTreeElement get(int a, int b) {
		segmentTreeElement vl = segmentTreeElement(),
			vr = segmentTreeElement();
		for (int l = a + RN, r = b + RN; l < r; l >>= 1, r >>= 1) {
			if (l & 1) vl = vl * array->at((l++) - 1);
			if (r & 1) vr = array->at((--r) - 1)*vr;
		}
		return vl * vr;
	}
};

int N;
vector<vector<int>> edges;
vector<int> C;
vector<int> ans;

void solve() {
	cin >> N;
	edges.resize(N);
	segTree seg(N);
	for (int n = 0; n < N-1; n++) {
		int a, b;
		cin >> a >> b;
		a--; b--;
		edges[a].push_back(b);
		edges[b].push_back(a);
	}
	C.resize(N);
	ans.resize(N);
	for (int n = 0; n < N; n++) {
		int c;
		cin >> c;
		C[n] = c;
	}
	sort(C.begin(), C.end());
	for (int n = 0; n < N; n++) {
		seg.set(n, segmentTreeElement(pii(edges[n].size(), n)));
	}
	long long sum = 0;
	for (int n = 0; n < N; n++) {
		pii cur = seg.get(0, N).ele;   //残っているものの中で入出時数最小
		sum += C[n] * cur.first;
		ans[cur.second] = C[n];
		seg.set(cur.second, segmentTreeElement(pii(INT_MAX, cur.second)));
		for (auto itr = edges[cur.second].begin(); itr != edges[cur.second].end(); itr++) {
			if (seg[*itr].ele.first == INT_MAX)continue;   //消去済み
			segmentTreeElement next = seg[*itr];
			next.ele.first--;
			seg.set(*itr,next);
		}
	}
	cout << sum << endl;
	for (int n = 0; n < N; n++)cout << ans[n] << endl;
	return;
}
