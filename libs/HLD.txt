template<class T>
struct HLDnode {
	LL depth;
	VLL nums;
	LL parent;
	VLL childs;
	LL pad;
	HLDnode() :depth(0),parent(-1),pad(0){};
};

template<class T>
struct HLD {
	vector<HLDnode<T>> tree;
	vector<PLL> corres;   //corres[n]:=(u,v) <==> point n is tree[u][v]
	LL V;
	vector<PLL> eulerind;
	HLD(Tree& t, LL root = 0) {
		V = t.size();
		VLL subtrees(V, -1);
		//各部分木のサイズを求める
		{
			stack<LL> order;
			stack<LL> hold;
			hold.push(root);
			while (!hold.empty()) {
				LL cur = hold.top();
				hold.pop();
				order.push(cur);
				for (LL ch : t[cur].childs) {
					hold.push(ch);
				}
			}
			while (!order.empty()) {
				LL cur = order.top();
				order.pop();
				subtrees[cur] = 1;
				for (LL ch : t[cur].childs) {
					subtrees[cur] += subtrees[ch];
				}
			}
		}
		//HL分解 with eulertour
		{
			corres.resize(V);
			corres[root] = PLL(0, 0);
			eulerind.resize(V);
			LL cur = root;
			LL nexthld = 1;
			LL nexteuler = 0;
			tree.push_back(HLDnode<T>());
			tree[0].nums.push_back(root);
			dfs(t, subtrees, cur, nexthld, nexteuler);
			////各HLDnodeのセグ木を初期化
			//for (HLDnode<T>& node : tree) {
			//	node.seg = Segtree<T>(node.nums.size());
			//	for (LL n = 0; n < node.nums.size(); n++) {
			//		node.seg.set(n, cont[node.nums[n]]);
			//	}
			//}
		}
	}
	void dfs(Tree& t,VLL& subtrees,LL cur, LL& nexthld,LL& nexteuler) {
		LL hld = corres[cur].first;
		eulerind[cur].first = nexteuler++;
		if (t[cur].childs.size() == 0)
		{
			eulerind[cur].second = nexteuler - 1;
			return;
		}
		LL maxsub = t[cur].childs[0];
		for (LL cn = 1; cn < t[cur].childs.size(); cn++) {
			if (subtrees[maxsub] < subtrees[t[cur].childs[cn]]) {
				maxsub = t[cur].childs[cn];
			}
		}
		tree[hld].nums.push_back(maxsub);
		corres[maxsub] = PLL(hld, tree[hld].nums.size() - 1);
		dfs(t, subtrees, maxsub, nexthld, nexteuler);
		for (LL ch : t[cur].childs) {
			if (ch == maxsub)continue;
			corres[ch] = PLL(nexthld, 0);
			tree.push_back(HLDnode<T>());
			tree.back().depth = tree[hld].depth + 1;
			tree.back().nums.push_back(ch);
			tree.back().parent = cur;
			tree[hld].childs.push_back(nexthld++);
			LL neold = nexteuler;
			dfs(t, subtrees, ch, nexthld, nexteuler);
			tree[corres[ch].first].pad = neold;
		}
		eulerind[cur].second = nexteuler - 1;
	}
	LL LCA(LL u, LL v) {
		//uの属するnode.depth >= vの属するnode.depthにする
		if (tree[corres[u].first].depth < tree[corres[v].first].depth) {
			swap(u, v);
		}
		while (tree[corres[u].first].depth > tree[corres[v].first].depth) {
			u = tree[corres[u].first].parent;
		}
		while (corres[u].first != corres[v].first) {
			u = tree[corres[u].first].parent;
			v = tree[corres[v].first].parent;
		}
		if (corres[u].second > corres[v].second)return v;
		else return u;
	}
};

https://beet-aizu.hatenablog.com/entry/2017/12/12/235950
https://codeforces.com/blog/entry/53170
https://qiita.com/ageprocpp/items/8dfe768218da83314989