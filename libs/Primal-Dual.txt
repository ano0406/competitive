template<class F,class C>
class MinCFEdge {
public:
	int to;
	F cap;
	C cost;
	int rev;
	MinCFEdge(int _to,F _cap,C _cost,int _rev):to(_to),cap(_cap),cost(_cost),rev(_rev){}
};

template<class F,class C>
class PrimalDual {
public:
	int V;
	C INF = numeric_limits<F>::max();
	vector<vector<MinCFEdge<F, C>>> G;
	vector<C> potential,dist;
	VI prevv, preve;
	PrimalDual(int v):V(v) {
		potential.resize(V, 0);
		dist.resize(V, 0);
		prevv.resize(V, -1);
		preve.resize(V, -1);
		G.resize(V);
	}
	void AddEdge(int from, int to, F cap, C cost) {
		G[from].push_back({ to, cap, cost, (int)G[to].size() });
		G[to].push_back({ from,0, -cost, (int)G[from].size() - 1 });
	}
	C min_cost_flow(int s,int t,F flow) {
		fill(potential.begin(), potential.end(), 0);
		typedef pair<C, int> P;
		C res = 0;
		while (flow > 0) {
			//dijkstra
			priority_queue<P, vector<P>, greater<P>> q;
			fill(dist.begin(), dist.end(), INF);
			dist[s] = 0;
			q.emplace(0, s);
			while (!q.empty()) {
				C cost = q.top().first;
				int cur = q.top().second;
				q.pop();
				if (dist[cur] < cost)continue;
				for (int i = 0; i < G[cur].size(); i++) {
					MinCFEdge<F,C>& e = G[cur][i];
					if (e.cap <= 0)continue;
					if (dist[e.to] <= dist[cur] + e.cost + potential[cur] - potential[e.to])continue;
					dist[e.to] = dist[cur] + e.cost + potential[cur] - potential[e.to];
					prevv[e.to] = cur;
					preve[e.to] = i;
					q.emplace(dist[e.to], e.to);
				}
			}
			if (dist[t] == INF)return -1;
			for (int v = 0; v < V; v++)potential[v] += dist[v];
			F f = flow;
			int v = t;
			while (v != s) {
				f = min(f, G[prevv[v]][preve[v]].cap);
				v = prevv[v];
			}
			flow -= f;
			res += potential[t] * f;
			v = t;
			while (v != s) {
				MinCFEdge<F,C>& e = G[prevv[v]][preve[v]];
				e.cap -= f;
				MinCFEdge<F,C>& rev = G[e.to][e.rev];
				rev.cap += f;
				v = prevv[v];
			}
		}
		return res;
	}
};

https://snuke.hatenablog.com/entry/2017/06/07/115821