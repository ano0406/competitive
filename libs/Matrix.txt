template<class K>
class Matrix {
public:
	vector<vector<K>> v;
	int H, W;
	Matrix(int h,int w):H(h),W(w){
		v.resize(h, vector<K>(w,K(0)));
	}
	Matrix(vector<K>& v0) {
		H = v0.size();
		W = 1;
		v.resize(H,vector<K>(1,T(0)));
		for (int y = 0; y < H; y++) {
			v[y][0] = v0[y];
		}
	}
	Matrix():H(0),W(0) {}
	void resize(int h, int w) {
		H = h;
		W = w;
		v.resize(H, vector<K>(W,K(0)));
	}
	vector<K>& operator[](int y) {
		return v[y];
	}
	vector<K>& back() {
		return v.back();
	}
	Matrix<K>& operator+=(Matrix<K>& B);
	Matrix<K>& operator-=(Matrix<K>& B);
	Matrix<K>& operator*=(Matrix<K>& B);
	Matrix<K>& operator*=(K k);
	Matrix<K>& operator/=(K k);
};

template<class K>
Matrix<K> operator+(Matrix<K>& A, Matrix<K>& B) {
	assert(A.H==B.H && A.W==B.W);
	int H = A.H;
	int W = A.W;
	Matrix<K> C(H, W);
	for (int y = 0; y < H; y++) {
		for (int x = 0; x < W; x++) {
			C[y][x] = A[y][x] + B[y][x];
		}
	}
	return C;
}

template<class K>
Matrix<K> operator-(Matrix<K>& A, Matrix<K>& B) {
	assert(A.H == B.H && A.W == B.W);
	int H = A.H;
	int W = A.W;
	Matrix<K> C(H, W);
	for (int y = 0; y < H; y++) {
		for (int x = 0; x < W; x++) {
			C[y][x] = A[y][x] - B[y][x];
		}
	}
	return C;
}

template<class K>
Matrix<K> operator*(Matrix<K>& A, Matrix<K>& B) {
	assert(A.W == B.H);
	int H = A.H;
	int W = B.W;
	Matrix<K> C(H, W);
	for (int k = 0; k < A.W; k++) {
		for (int y = 0; y < H; y++) {
			for (int x = 0; x < W; x++) {
				C[y][x] += A[y][k] * B[k][x];
			}
		}
	}
	return C;
}

template<class K>
Matrix<K> operator*(Matrix<K>& A, K k) {
	int H = A.H;
	int W = A.W;
	Matrix<K> C(H, W);
	for (int y = 0; y < A.H; y++) {
		for (int x = 0; x < A.W; x++) {
			C[y][x] = A[y][x] * k;
		}
	}
	return C;
}

template<class K>
Matrix<K> operator*(K k,Matrix<K>& A) {
	int H = A.H;
	int W = A.W;
	Matrix<K> C(H, W);
	for (int y = 0; y < A.H; y++) {
		for (int x = 0; x < A.W; x++) {
			C[y][x] = A[y][x] * k;
		}
	}
	return C;
}

template<class K>
Matrix<K> operator/(Matrix<K>& A, K k) {
	int H = A.H;
	int W = A.W;
	Matrix<K> C(H, W);
	for (int y = 0; y < A.H; y++) {
		for (int x = 0; x < A.W; x++) {
			C[y][x] = A[y][x] / k;
		}
	}
	return C;
}

template<class K>
Matrix<K>& Matrix<K>::operator+=(Matrix<K>& B) {
	assert(H == B.H && W == B.W);
	for (int y = 0; y < H; y++) {
		for (int x = 0; x < W; x++) {
			v[y][x] += B[y][x];
		}
	}
	return *this;
}

template<class K>
Matrix<K>& Matrix<K>::operator-=(Matrix<K>& B) {
	assert(H == B.H && W == B.W);
	for (int y = 0; y < H; y++) {
		for (int x = 0; x < W; x++) {
			v[y][x] -= B[y][x];
		}
	}
	return *this;
}

template<class K>
Matrix<K>& Matrix<K>::operator*=(Matrix<K>& B) {
	*this = *this * B;
	return *this;
}

template<class K>
Matrix<K>& Matrix<K>::operator*=(K k) {
	for (int y = 0; y < H; y++) {
		for (int x = 0; x < W; x++) {
			v[y][x] *= k;
		}
	}
	return *this;
}

template<class K>
Matrix<K>& Matrix<K>::operator/=(K k) {
	for (int y = 0; y < H; y++) {
		for (int x = 0; x < W; x++) {
			v[y][x] /= k;
		}
	}
	return *this;
}

template<class K>
bool operator==(Matrix<K>& A, Matrix<K>& B) {
	if (A.H != B.H || A.W != B.W)return false;
	for (int y = 0; y < A.H; y++) {
		for (int x = 0; x < A.W; x++) {
			if (A[y][x] != B[y][x])return false;
		}
	}
	return true;
}

template<class K>
bool operator!=(Matrix<K>& A, Matrix<K>& B) {
	return !(A == B);
}

template<class K>
Matrix<K> pow(Matrix<K>& A, LL p) {
	assert(A.H == A.W);
	if (p == 1)return A;
	Matrix<K> temp = pow(A, p >> 1);
	temp *= temp;
	if (p == 1) {
		temp *= A;
	}
	return temp;
}

//行列Aを階段行列に変換する
//返り値:行列のランク
template<class K>
int ConvertToStair(Matrix<K>& A) {
	int H = A.H;
	int W = A.W;
	int x = 0, y = 0;
	while (true) {
		if (x >= W || y >= H)break;
		if (A[y][x] == K()) {
			int yy = y + 1;
			for (; yy < H; yy++) {
				if (A[yy][x] != K()) {
					swap(A[yy], A[y]);
					for (int xx = x; xx < W; xx++) {
						A[yy][xx] *= K(-1);
					}
					break;
				}
			}
			if (yy == H) {
				x++;
				continue;
			}
		}
		for (int yy = y + 1; yy < H; yy++) {
			K f = A[yy][x] / A[y][x];
			for (int xx = x; xx < W; xx++) {
				A[yy][xx] = A[yy][xx] - A[y][xx] * f;
			}
		}
		x++;
		y++;
	}
	return y;
}

//行列Aを階段行列に変換する
//conv[y][x] := 元の行列A_xを何回加えて今のA_yにしたか
//返り値:行列のランク
template<class K>
int ConvertToStair(Matrix<K>& A, vector<vector<K>>& conv) {
	int H = A.H;
	int W = A.W;
	int x = 0, y = 0;
	conv.resize(H, vector<K>(H, K()));
	for (int yy = 0; yy < H; yy++) {
		conv[yy][yy] = K(1);
	}
	while (true) {
		if (x >= W || y >= H)break;
		if (A[y][x] == K()) {
			int yy = y + 1;
			for (; yy < H; yy++) {
				if (A[yy][x] != K()) {
					swap(A[yy], A[y]);
					swap(conv[yy], conv[y]);
					for (int xx = x; xx < W; xx++) {
						A[yy][xx] *= K(-1);
					}
					for (int n = 0; n < H; n++) {
						conv[yy][n] *= K(-1);
					}
					break;
				}
			}
			if (yy == H) {
				x++;
				continue;
			}
		}
		for (int yy = y + 1; yy < H; yy++) {
			K f = A[yy][x] / A[y][x];
			for (int xx = x; xx < W; xx++) {
				A[yy][xx] = A[yy][xx] - A[y][xx] * f;
			}
			for (int n = 0; n < H; n++) {
				conv[yy][n] -= conv[y][n] * f;
			}
		}
		x++;
		y++;
	}
	return y;
}

//行列式を求める
template<class K>
K Determinant(Matrix<K>& A) {
	ConvertToStair(A);
	K ans(1);
	for (int y = 0; y < A.H; y++) {
		ans *= A[y][y];
	}
	return ans;
}

//線型方程式を解く
//返り値:解の有無
//particular:特殊解
//bases:解空間の基底
template<class K>
bool SolveLinearEquations(Matrix<K>& A, vector<K>& B, vector<vector<K>>& bases, vector<K>& particular) {
	int H = A.H;
	int W = A.W;
	int X = 0, Y = 0;
	//階段行列に変形
	while (true) {
		if (X >= W || Y >= H)break;
		if (A[Y][X] == K()) {
			int y = Y + 1;
			for (; y < H; y++) {
				if (A[y][X] != K()) {
					swap(A[y], A[Y]);
					swap(B[y], B[Y]);
					break;
				}
			}
			if (y == H) {
				X++;
				continue;
			}
		}
		for (int y = Y + 1; y < H; y++) {
			K f = A[y][X] / A[Y][X];
			for (int x = X; x < W; x++) {
				A[y][x] = A[y][x] - A[Y][x] * f;
			}
			B[y] -= B[Y] * f;
		}
		X++;
		Y++;
	}
	//元のAのランクと、AにBをくっつけた拡張行列のランクが等しいか確かめる
	for (int y = Y; y < H; y++) {
		if (B[y] != K(0)) {
			//解は存在しない
			return false;
		}
	}
	int rank = Y;
	bases.resize(W - rank, vector<K>(W, K(0)));
	//右上三角行列を作るように列を取っていく
	particular.resize(W, K(0));
	X = 0;
	Y = 0;
	VI use;   //取る列
	VI notuse;   //取らない列
	while (X < W && Y < rank) {
		if (A[Y][X] == K(0)) {
			notuse.push_back(X);
			X++;
		}
		else {
			use.push_back(X);
			X++;
			Y++;
		}
	}
	while (X < W) {
		notuse.push_back(X);
		X++;
	}
	//特殊解を求める
	for (int x : notuse) {
		particular[x] = K(0);
	}
	for (int y = rank - 1; y >= 0; y--) {
		K b = B[y];
		for (int x = y + 1; x < rank; x++) {
			b -= A[y][use[x]] * particular[use[x]];
		}
		particular[use[y]] = b / A[y][use[y]];
	}
	//解空間の基底
	for (int base = 0; base < W - rank; base++) {
		vector<K>& v = bases[base];
		for (int x : notuse) {
			v[x] = K(0);
		}
		v[notuse[base]] = K(1);
		for (int y = rank - 1; y >= 0; y--) {
			K b = -1 * A[y][notuse[base]];
			for (int x = y + 1; x < rank; x++) {
				b -= A[y][use[x]] * v[use[x]];
			}
			v[use[y]] = b / A[y][use[y]];
		}
	}
	return true;
}

//線型方程式を解く
//返り値:解空間の有無
//particular:特殊解
template<class K>
bool SolveLinearEquations(Matrix<K>& A, vector<K>& B, vector<K>& particular) {
	int H = A.H;
	int W = A.W;
	int X = 0, Y = 0;
	//階段行列に変形
	while (true) {
		if (X >= W || Y >= H)break;
		if (A[Y][X] == K()) {
			int y = Y + 1;
			for (; y < H; y++) {
				if (A[y][X] != K()) {
					swap(A[y], A[Y]);
					swap(B[y], B[Y]);
					break;
				}
			}
			if (y == H) {
				X++;
				continue;
			}
		}
		for (int y = Y + 1; y < H; y++) {
			K f = A[y][X] / A[Y][X];
			for (int x = X; x < W; x++) {
				A[y][x] = A[y][x] - A[Y][x] * f;
			}
			B[y] -= B[Y] * f;
		}
		X++;
		Y++;
	}
	//元のAのランクと、AにBをくっつけた拡張行列のランクが等しいか確かめる
	for (int y = Y; y < H; y++) {
		if (B[y] != K(0)) {
			//解は存在しない
			return false;
		}
	}
	int rank = Y;
	//右上三角行列を作るように列を取っていく
	particular.resize(W, K(0));
	X = 0;
	Y = 0;
	VI use;   //取る列
	VI notuse;   //取らない列
	while (X < W && Y < rank) {
		if (A[Y][X] == K(0)) {
			notuse.push_back(X);
			X++;
		}
		else {
			use.push_back(X);
			X++;
			Y++;
		}
	}
	while (X < W) {
		notuse.push_back(X);
		X++;
	}
	//特殊解を求める
	for (int x : notuse) {
		particular[x] = K(0);
	}
	for (int y = rank - 1; y >= 0; y--) {
		K b = B[y];
		for (int x = y + 1; x < rank; x++) {
			b -= A[y][use[x]] * particular[use[x]];
		}
		particular[use[y]] = b / A[y][use[y]];
	}
	return true;
}
