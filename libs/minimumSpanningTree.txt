//最小全域木クラス版:
//最小全域木問題(クラスカル法)
//最小全域木自体と、重み和
//wGraphに追加する感じで
//O( ElogV )
	T minimumSpanningTree() {
		typedef pair<T, pii> ldii;
		priority_queue<ldii, vector<ldii>, greater<ldii> >* q;
		q = new priority_queue<ldii, vector<ldii>, greater<ldii> >;
		for (int i = 0; i < this->N; i++) {
			for (auto itr = this->E->at(i).begin(); itr != this->E->at(i).end(); itr++) {
				q->push(ldii((*itr).second, pii(i, (*itr).first)));
			}
		}
		wGraph<T>* g = new wGraph<T>(this->N);
		unionFind* u = new unionFind(this->N);
		T ans = 0;
		while (!q->empty()) {
			ldii e = q->top();
			q->pop();
			int s = e.second.first, t = e.second.second;
			if (u->parent(s) != u->parent(t)) {
				u->unit(s, t);
				ans += e.first;
			}
		}
		delete u;
		delete g;
		return ans;
	}


//一般版?unionfind必要 ただし無向辺
int V,E;   //それぞれ頂点数、辺数
struct edge {
	int u, v, w;
};   //無向辺管理のクラス(u,v:頂点、w:重み) この場合、(u,v)と(v,u)両方を登録、みたいなことはない
vector<edge> Edges;   //辺集合

####################


sort(Edges.begin(), Edges.end(), [](edge a, edge b) {return a.w < b.w; });
int res = 0;   //結果
unionFind uf(V);
for (int e = 0; e < E; e++) {
	if (uf[Edges[e].u] == uf[Edges[e].v])continue;
	uf.unit(Edges[e].u, Edges[e].v);
	res += Edges[e].w;
}
