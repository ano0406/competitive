class Modint {
public:
	LL v;
	Modint(LL _v) {
		_v %= MOD;
		if (_v < 0)_v += MOD;
		v = _v;
	}
	Modint operator+=(Modint m);
	Modint operator-=(Modint m);
	Modint operator*=(Modint m);
	Modint operator/=(Modint m);
	friend ostream& operator<<(ostream& st, const Modint& m);
	friend istream& operator>>(istream& st, Modint& m);
	Modint() :v(0) {}
	static Modint one;
};
bool operator==(Modint a, Modint b) {
	return a.v == b.v;
}
bool operator!=(Modint a, Modint b) {
	return a.v != b.v;
}
Modint Modint::one = Modint(1);
template<class T>
T pow(T& base, LL p) {
	if (p == 0)return T();
	else if (p == 1)return base;
	T ret = pow(base, p / 2);
	ret *= ret;
	if (p & 1)ret *= base;
	return ret;
}
template<class T>
T modpow(T base, LL p) {
	if (p == 0)return T();
	else if (p == 1)return base;
	T ret = modpow(base, p / 2);
	ret *= ret;
	if (p & 1)ret *= base;
	return ret;
}
ostream& operator<<(ostream& st, const Modint& m) {
	cout << m.v;
	return st;
}
istream& operator>>(istream& st, Modint& m) {
	LL v;
	cin >> v;
	m.v = v % MOD;
	return st;
}
Modint operator+(Modint a, Modint b) {
	Modint r;
	r.v = a.v + b.v;
	if (r.v >= MOD)r.v -= MOD;
	return r;
}
Modint operator-(Modint a, Modint b) {
	Modint r;
	r.v = a.v - b.v;
	if (r.v < 0)r.v += MOD;
	return r;
}
Modint operator*(Modint a, Modint b) {
	return Modint((a.v * b.v) % MOD);
}
Modint operator+(Modint a, LL b) {
	return Modint(a.v + b);
}
Modint operator+(LL a, Modint b) {
	return Modint(a + b.v);
}
Modint operator-(Modint a, LL b) {
	return Modint(a.v - b);
}
Modint operator-(LL a, Modint b) {
	return Modint(a - b.v);
}
Modint operator*(Modint a, LL b) {
	return Modint(a.v * (b % MOD));
}
Modint operator*(LL a, Modint b) {
	return Modint((a % MOD) * b.v);
}
Modint operator/(Modint a, Modint b) {
	return a * modpow(b, MOD - 2);
}
Modint Modint::operator+=(Modint m) {
	*this = *this + m;
	return *this;
}
Modint Modint::operator-=(Modint m) {
	*this = *this - m;
	return *this;
}
Modint Modint::operator*=(Modint m) {
	*this = *this * m;
	return *this;
}
Modint Modint::operator/=(Modint m) {
	*this *= modpow(m, MOD - 2);
	return *this;
}
//O(min(N-R,R))
Modint Comb(LL N, LL R) {
	if (R > N - R)return Comb(N, N - R);
	Modint ans((LL)1);
	for (LL n = N; n > N - R; n--) {
		ans *= Modint(n);
	}
	for (LL n = R; n >= 1; n--) {
		ans *= modpow(Modint(n), MOD - 2);
	}
	return ans;
}