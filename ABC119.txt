void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <functional>
#include <map>
#include <stack>

using namespace std;

int A, B;
int QN;
vector<long long> S, T;
vector<long long> P, Q;
vector<long long> PpS, PmS, QpT, QmT;
vector<long long> ans;

//s_i <= x ‚©‚Âs_i+1 > x‚È‚éi‚ðŒ©‚Â‚¯‚é
int findS(long long x) {
	int s = 0-1, e = A+1;
	while (e - s > 1) {
		int m = (s + e) / 2;
		if (S[m] <= x)s = m;
		else e = m;
	}
	return s;
}

int findT(long long x) {
	int s = -1, e = B+1;
	while (e - s > 1) {
		int m = (s + e) / 2;
		if (T[m] <= x)s = m;
		else e = m;
	}
	return s;
}

void solve() {
	cin >> A >> B >> QN;
	S.resize(A+2);
	T.resize(B+2);
	S[0] = -100000000000;
	S[A + 1] = 100000000000;
	T[0] = -100000000000;
	T[B + 1] = 100000000000;
	for (int a = 1; a <= A; a++)cin >> S[a];
	for (int b = 1; b <= B; b++)cin >> T[b];
	P.resize(A+2);
	Q.resize(B+2);
	for (int a = 1; a <= A; a++) {
		int n = findT(S[a]);
		P[a] = min(S[a]-T[n],T[n+1]-S[a]);
	}
	P[0] = 100000000000;
	P[A + 1] = 100000000000;
	for (int b = 1; b <= B; b++) {
		int n = findS(T[b]);
		Q[b] = min(T[b] - S[n], S[n + 1] - T[b]);
	}
	Q[0] = 100000000000;
	Q[B + 1] = 100000000000;
	PpS.resize(A + 2);
	PmS.resize(A + 2);
	QpT.resize(B + 2);
	QmT.resize(B + 2);
	PpS[0] = 100000000000;
	PpS[A + 1] = 100000000000;
	PmS[0] = 100000000000;
	PmS[A + 1] = 100000000000;
	QpT[0] = 100000000000;
	QpT[B + 1] = 100000000000;
	QmT[0] = 100000000000;
	QmT[B + 1] = 100000000000;
	for (int a = 1; a <= A; a++) {
		PmS[a] = min(PmS[a-1],P[a]-S[a]);
		PpS[A - a + 1] = min(PpS[A - a + 2], P[A - a + 1] + S[A - a + 1]);
	}
	PmS[A + 1] = PmS[A];
	PpS[0] = PpS[1];
	for (int b = 1; b <= B; b++) {
		QmT[b] = min(QmT[b - 1], Q[b] - T[b]);
		QpT[B - b + 1] = min(QpT[B - b + 2], Q[B - b + 1] + T[B - b + 1]);
	}
	QmT[B + 1] = QmT[B];
	QpT[0] = QpT[1];
	for (int prob = 0; prob < QN; prob++) {
		long long x;
		cin >> x;
		int n = findS(x);
		long long temp = x + PmS[n];
		temp = min(temp, PpS[n + 1] - x);
		n = findT(x);
		temp = min(temp, x + QmT[n]);
		temp = min(temp, QpT[n + 1] - x);
		ans.push_back(temp);
	}
	for (int i = 0; i < QN; i++)cout << ans[i] << endl;
	return;
}