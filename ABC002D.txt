#include <iostream>
#include <set>
#include <math.h>
#include <string>
#include <algorithm>

using namespace std;

void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////

class relation {
public:
	int x, y;
	relation(int _x, int _y){
		x = _x, y = _y;
	}
	relation() {
		x = 0; y = 0;
	}
	bool operator==(relation r) {
		if ((x == r.x && y == r.y) || (x == r.y && y == r.x))return true;
		else return false;
	}
};

int N, M;
relation arr[66];
bool isIn(relation);   //すべての関係の中に、この関係が含まれるか
int group(int);   //この構成でグループが成立しているかどうか

void solve() {
	cin >> N >> M;
	for (int i = 0; i < M; i++) {
		int x, y;
		cin >> x >> y;
		arr[i] = relation(x-1,y-1);
	}
	int maxnum = 0;
	for (int b = 0; b < pow(2, N); b++) {
		maxnum = max(maxnum,group(b));
	}
	cout << maxnum << endl;
	return;
}

bool isIn(relation r) {
	for (int i = 0; i < M; i++) {
		if (arr[i] == r)return true;
	}
	return false;
}

int group(int b){
	bool bmap[12];   //グループに入ってたらtrue
	bool gflag = true;   //グループとして成立するならtrue
	for (int i = 0; i < N; i++)bmap[i] = false;
	for (int i = 0; i < N && gflag; i++) {
		if ((b & (int)pow(2, i)) == 0) {   //番号が前の人との関係があるか調べていく
			bmap[i] = true;
			for (int j = 0; j < i; j++) {
				if (!bmap[j])continue;   //グループ内にいない
				if (!isIn(relation(j, i))) {
					gflag = false;
					break;
				}
			}
		}
	}
	if (gflag) {
		int m = 0;
		for (int i = 0; i < N; i++) {
			if (bmap[i])m++;
		}
		return m;
	}
	else return 0;
}