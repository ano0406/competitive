#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
using namespace std;
long long MOD = 1e9 + 7;

//重み付きグラフ
//距離の部分をテンプレートに
template<class T>
class wGraph {
public:
	int N;
	vector<vector<pair<int, T>>>* E;
	wGraph(int n, T i) {
		N = n;
		E = new vector<vector<pair<int, T>>>;
		E->resize(N);
		INF = i;
	}
	wGraph() {
	}
	void constructor(int n, T i) {
		N = n;
		E = new vector<vector<pair<int, T>>>;
		E->resize(N);
		INF = i;
	}
	~wGraph() {
		delete E;
	}
	void addEdge(int a, int b, T c) {
		E->at(a).push_back(pair<int, T>(b, c));
	}
	T INF;
};

//ワーシャルフロイド、全点対最短路
//グラフと結果保存用
//到達不可能はg.INF
//O(|V|^3)
template<class T>
void warshallFloyd(wGraph<T>& g, vector<vector<T>>& array) {
	array.resize(g.N);
	for (auto itr = array.begin(); itr != array.end(); itr++) {
		(*itr).resize(g.N);
		fill((*itr).begin(), (*itr).end(), g.INF);
	}
	for (int n = 0; n < g.N; n++)array[n][n] = 0;
	for (int n = 0; n < g.N; n++) {
		for (auto itr = g.E->at(n).begin(); itr != g.E->at(n).end(); itr++) {
			array[n][(*itr).first] = min(array[n][(*itr).first], (*itr).second);
		}
	}
	for (int k = 0; k < g.N; k++) {
		for (int i = 0; i < g.N; i++) {
			for (int j = 0; j < g.N; j++) {
				if (array[i][k] != g.INF && array[k][j] != g.INF) {
					array[i][j] = min(array[i][j], array[i][k] + array[k][j]);
				}
			}
		}
	}
	return;
}

long long N, M, L;

int main() {
	cin >> N >> M >> L;
	wGraph<long long> G0(N,INT_MAX);
	for (int m = 0; m < M; m++) {
		int a, b, c;
		cin >> a >> b >> c;
		G0.addEdge(--a, --b, c);
		G0.addEdge(b, a, c);
	}
	vector<vector<long long>> belans;
	warshallFloyd(G0, belans);
	wGraph<long long> G(N, INT_MAX);
	for (int s = 0; s < N; s++) {
		for (int t = 0; t < N; t++) {
			if (s == t)continue;
			if (belans[s][t] <= L)G.addEdge(s, t, 1);
		}
	}
	vector<vector<long long>> ans;
	warshallFloyd(G, ans);
	int Q;
	cin >> Q;
	for (int q = 0; q < Q; q++) {
		int s, t;
		cin >> s >> t;
		if (ans[--s][--t] == INT_MAX)cout << -1 << endl;
		else cout << ans[s][t]-1 << endl;
	}
	return 0;
}
