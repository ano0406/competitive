#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
using namespace std;
long long MOD = 1e9 + 7;

int N, M;
vector<int> V;
vector<vector<long long>> DP;   //è„å¿ÅAòa
vector<int> primes;
vector<int> counter;

int main() {
	cin >> N >> M;
	int copym = M;
	for (int p = 2; p * p <= copym; p++) {
		if (copym % p == 0) {
			primes.push_back(p);
			counter.push_back(0);
			while (copym % p == 0) {
				copym /= p;
				counter.back()++;
			}
		}
	}
	if (copym != 1) {
		primes.push_back(copym);
		counter.push_back(1);
	}
	//ägí£ägí£EuclidÇÃå›èúñ@Ç…ÇÊÇÈ(äKèÊ)ãtå≥ÇÃãÅÇﬂï˚
	//O(N)
	vector<long long> inv, sinv,stairs;   //inv[i]*i%M = 1,sinv[i]*(i!)%M = 1(0<=i<=N)
	inv.resize(100000+50 + 1);
	sinv.resize(100000+50 + 1);
	stairs.resize(100000 + 50 + 1);
	stairs[0] = 1;
	stairs[1] = 1;
	inv[1] = 1;
	sinv[0] = 1;
	sinv[1] = 1;
	for (int n = 2; n <= 100000+50; n++) {
		stairs[n] = (stairs[n - 1] * n) % MOD;
		inv[n] = MOD - (inv[MOD % n] * (MOD / n)) % MOD;
		sinv[n] = (sinv[n - 1] * inv[n]) % MOD;
	}
	long long ans = 1;
	for (int p = 0; p < primes.size(); p++) {
		int S = counter[p];
		long long temp = stairs[S + N - 1] * sinv[S];
		temp %= MOD;
		temp = (temp * sinv[N - 1]) % MOD;
		ans *= temp;
		ans %= MOD;
	}
	cout << ans << endl;
	return 0;
}
