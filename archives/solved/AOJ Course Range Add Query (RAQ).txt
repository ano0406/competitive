#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>

using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 1e9 + 7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
typedef vector<ll> VLL;
typedef vector<VLL> VVLL;
//typedef boost::multiprecision::cpp_int bigint;

vector<ll> seg, lazy;

void eval(ll k,ll l,ll r) {
	if (k >= seg.size())return;
	if (lazy[k] == 0)return;
	seg[k] += lazy[k]*(r-l+1);
	if (k < seg.size() / 2) {
		lazy[2 * k] += lazy[k];
		lazy[2 * k + 1] += lazy[k];
	}
	lazy[k] = 0;
}

void change(ll a, ll b, ll x, ll k = 1, ll l = 0, ll r = seg.size() / 2 - 1) {
	eval(k,l,r);
	if (r < a || b < l)return;
	if (a <= l && r <= b) {
		lazy[k] += x;
		eval(k,l,r);
	}
	else {
		change(a, b, x, 2 * k, l, (l + r) / 2);
		change(a, b, x, 2 * k + 1, (l + r) / 2+1, r);
		seg[k] = seg[2 * k] + seg[2 * k + 1];
	}
}

ll get(ll a, ll b, ll k = 1, ll l = 0, ll r = seg.size() / 2 - 1) {
	if (r < a || b < l)return 0;
	eval(k, l, r);
	if (a <= l && r <= b)return seg[k];
	else return get(a, b, 2 * k, l, (l + r) / 2) + get(a, b, 2 * k + 1, (l + r) / 2 + 1, r);
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	ll N,Q;
	cin >> N >> Q;
	ll RN = 1;
	while (RN < N)RN *= 2;
	seg.resize(2 * RN);
	lazy.resize(2 * RN);
	for (ll q = 0; q < Q; q++) {
		ll cmd;
		cin >> cmd;
		if (cmd == 0) {
			ll s, t, x;
			cin >> s >> t >> x;
			change(--s, --t, x);
		}
		else {
			ll i;
			cin >> i;
			i--;
			cout << get(i, i) << "\n";
		}
	}
	return 0;
}