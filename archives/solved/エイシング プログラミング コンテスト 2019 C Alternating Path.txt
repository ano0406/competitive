#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
using namespace std;

template<class T>
void in(vector<T>& V) {
	for (auto itr = V.begin(); itr != V.end(); itr++)cin >> *itr;
	return;
}

template<class T>
void out(vector<T>& V) {
	for (T& itr : V)cout << itr << endl;
	return;
}

typedef pair<int, int> pii;
vector<vector<bool>> M;
vector<vector<int>> MM;
int H, W;

int main() {
	cin >> H >> W;
	M.resize(W, vector<bool>(H));
	for (int y = 0; y < H; y++) {
		string S;
		cin >> S;
		for (int x = 0; x < W; x++) {
			if (S[x] == '.')M[x][y] = true;
			else M[x][y] = false;
		}
	}
	MM.resize(W, vector<int>(H,-1));
	int l = 0;
	long long ans = 0;
	for (int x = 0; x < W; x++) {
		for (int y = 0; y < H; y++) {
			if (MM[x][y] != -1)continue;
			long long bl = 0,wh = 0;
			queue<pii> q;
			q.push(pii(x, y));
			while (!q.empty()) {
				int cx = q.front().first;
				int cy = q.front().second;
				q.pop();
				if (MM[cx][cy] != -1)continue;
				MM[cx][cy] = l;
				if (M[cx][cy] == true)bl++;
				else wh++;
				int vec[4][2] = {
					{0,1},{0,-1},{1,0},{-1,0}
				};
				for (int v = 0; v < 4; v++) {
					int dx = cx + vec[v][0];
					int dy = cy + vec[v][1];
					if (dx < 0 || dx >= W || dy < 0 || dy >= H)continue;
					if (MM[dx][dy] != -1)continue;
					if (M[dx][dy] == M[cx][cy])continue;
					q.push(pii(dx, dy));
				}
			}
			l++;
			ans += bl * wh;
		}
	}
	cout << ans << endl;
	return 0;
}
