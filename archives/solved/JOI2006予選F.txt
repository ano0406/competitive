void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <functional>
#include <map>
#include <string>
#include <boost/multiprecision/cpp_int.hpp>
#include <limits.h>
#include <iomanip>
#include <stack>

using namespace std;
using namespace boost::multiprecision;

class pos {
public:
	int x, y;
	pos() :x(0), y(0) {};
	pos(int _x, int _y) :x(_x), y(_y) {};
};

bool operator<(pos a, pos b) {
	if (a.y != b.y)return a.y < b.y;
	return a.x < b.x;
}

vector<vector<long long>> dp;
vector<pos> stop;
int A, B,N;
vector<long long> ans;

void solve() {
	while (true) {
		cin >> A >> B;
		if (A == 0 && B == 0) {
			for (int i = 0; i < ans.size(); i++)cout << ans[i] << endl;
			return;
		}
		A--; B--;
		dp.clear();
		dp.resize(A+1);
		stop.clear();
		for (int x = 0; x <= A; x++) {
			dp[x].resize(B+1);
		}
		cin >> N;
		for (int n = 0; n < N; n++) {
			int x, y;
			cin >> x >> y;
			x--; y--;
			if (x > A || y > B)continue;
			pos a(x, y);
			stop.push_back(a);
		}
		sort(stop.begin(), stop.end());
		stop.push_back(pos(16, 16));
		int index = 0;
		dp[0][0] = 1;
		for (int y = 0; y <= B; y++) {
			for (int x = 0; x <= A; x++) {
				if (stop[index].x == x && stop[index].y == y) {
					index++;
					dp[x][y] = 0;
					continue;
				}
				if (x != 0)dp[x][y] += dp[x - 1][y];
				if (y != 0)dp[x][y] += dp[x][y - 1];
			}
		}
		ans.push_back(dp[A][B]);
	}
}