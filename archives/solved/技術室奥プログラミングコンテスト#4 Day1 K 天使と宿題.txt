void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
using namespace std;

class segmentTreeElement {
public:
	pair<int,int> ele;
	segmentTreeElement(pair<int,int> a) :ele(a) {};
	segmentTreeElement() :ele(pair<int,int>(0,0)) {};
};

segmentTreeElement operator*(segmentTreeElement& a, segmentTreeElement& b) {
	if (a.ele.first < b.ele.first)return b;
	else return a;
}

class segTree {
public:
	long long N;   //中身のある要素数
	long long RN;   //2の累乗数にするために合わせた、ゴミデータ含めた要素数
	vector<segmentTreeElement>* array;
	segmentTreeElement e;   //単位元
	//コンストラクタ:要素数、初期化用の数
	segTree(long long n, segmentTreeElement z) {
		N = n;
		RN = 1;
		e = z;
		while (RN < N)RN *= 2;
		array = new vector<segmentTreeElement>;
		array->resize(2 * RN - 1, e);
	}
	~segTree() {
		delete array;
	}
	void set(int n, segmentTreeElement t) {   //n番目の要素にtを設定
		n = RN + n - 1;
		array->at(n) = t;
		while (n > 0) {
			n = (n - 1) / 2;
			array->at(n) = array->at(2 * n + 1) * array->at(2 * n + 2);
		}
	}
	inline segmentTreeElement operator[](int a) {
		return array->at(RN + a - 1);
	}
	inline segmentTreeElement get(int a, int b) {
		segmentTreeElement vl = e, vr = e;
		for (int l = a + RN, r = b + RN; l < r; l >>= 1, r >>= 1) {
			if (l & 1) vl = vl * array->at((l++) - 1);
			if (r & 1) vr = array->at((--r) - 1) * vr;
		}
		return vl * vr;
	}
};

int N;

void solve() {
	cin >> N;
	segTree seg(N+1,segmentTreeElement());
	for (int n = 1; n <= N; n++) {
		int a;
		cin >> a;
		seg.set(n, segmentTreeElement(pair<int, int>(a, n)));
	}
	int l = N;
	int ans = 0;
	while (l > 0) {
		pair<int, int> m = seg.get(l, N+1).ele;
		l -= m.first;
		seg.set(m.second, segmentTreeElement(pair<int, int>(0, m.second)));
		ans++;
	}
	cout << ans << endl;
	return;
}
