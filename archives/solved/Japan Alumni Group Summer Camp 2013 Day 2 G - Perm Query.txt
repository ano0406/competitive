#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
using namespace std;
long long MOD = 1e9 + 7;
typedef pair<long long,long long> pii;

//空vectorを要素数NのsegTreeとしてzで初期化
template<class T>
void segTree_init(vector<T>& vec, int N, T z) {
	int RN = 1;
	while (RN < N)RN *= 2;
	vec.resize(2 * RN, z);
}

//vecをsegTreeとしてn番目をxに
template<class T>
void segTree_set(vector<T>& vec, int n, T x, function<T(T, T)> f, int k = -1) {
	int RN = (vec.size() + 1) / 2;
	if (k == -1) {
		k = n + RN;
		vec[k] = x;
		segTree_set(vec, n, x, f, k / 2);
	}
	else if (k != 0) {
		vec[k] = f(vec[2 * k], vec[2 * k + 1]);
		segTree_set(vec, n, x, f, k / 2);
	}
}

//vecがsegTreeの時の、n番目の要素
template<class T>
T segTree_at(vector<T>& vec, int n) {
	int RN = (vec.size()) / 2;
	return vec[RN + n];
}

//get [a,b]
template<class T>
T segTree_get(vector<T>& vec, int a, int b, function<T(T, T)> f, T e, int k = 1, int l = 0, int r = -1) {
	if (r == -1)r = vec.size() / 2 - 1;
	if (b < l || r < a)return e;
	else if (a <= l && r <= b)return vec[k];
	else return f(
		segTree_get(vec, a, b, f, e, 2 * k, l, (l + r) / 2),
		segTree_get(vec, a, b, f, e, 2 * k + 1, (l + r) / 2 + 1, r)
	);
}

template< typename T >
T extgcd(T a, T b, T& x, T& y) {
	T d = a;
	if (b != 0) {
		d = extgcd(b, a % b, y, x);
		y -= (a / b) * x;
	}
	else {
		x = 1;
		y = 0;
	}
	return d;
}

function<pii(pii, pii)> lambda = [](pii a, pii b) {
	long long x, y;
	long long g = extgcd<long long>(a.second, b.second,x,y);
	long long atimes = (b.second / g)%MOD;
	long long btimes = (a.second / g)%MOD;
	long long sum = (atimes * a.first) % MOD;
	sum = (sum + btimes * b.first) % MOD;
	return pii(sum, atimes * a.second);
};

int main() {
	int N,Q;
	cin >> N >> Q;
	vector<int> P(N + 1, 0);
	for (int n = 1; n <= N; n++) {
		cin >> P[n];
	}
	vector<pii> seg;   //和、ループの長さ
	segTree_init(seg, N+1, pii(0, 1));
	for (int n = 1; n <= N; n++) {
		int counter = 1;
		int x = P[n];
		long long sum = x;
		while (x != n) {
			x = P[x];
			counter++;
			sum = (sum+x)%MOD;
		}
		segTree_set(seg, n, pii(sum, counter), lambda);
	}
	for (int q = 0; q < Q; q++) {
		int l, r;
		cin >> l >> r;
		cout << segTree_get(seg, l, r, lambda, pii(0, 1)).first << endl;
	}
	return 0;
}