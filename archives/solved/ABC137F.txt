void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
using namespace std;

int P;
vector<long long> A;
vector<long long> inv, C;
vector<long long> ans;

template<class T>
T pow(T base, int p, T mod = -1) {
	if (p == 0)return 1;
	if (p == 1)return mod == -1 ? base % mod : base;
	int b = 1, c = 0;
	while (b <= p) {
		b *= 2;
		c++;
	}
	T* arr2 = new T[c];   //T[n] = T^(2^n)
	arr2[0] = mod == -1 ? base % mod : base;
	for (int n = 1; n < c; n++) {
		if (mod != -1)arr2[n] = (arr2[n - 1] * arr2[n - 1]) % mod;
		else arr2[n] = arr2[n - 1] * arr2[n - 1];
	}
	c--;
	T ans = arr2[c];
	b /= 2;
	p -= b;
	while (p > 0) {
		c--;
		b /= 2;
		if (p >= b) {
			if (mod != -1)ans = (ans * arr2[c]) % mod;
			else ans = ans * arr2[c];
			p -= b;
		}
	}
	return ans;
}

void solve() {
	cin >> P;
	A.resize(P);
	for (int p = 0; p < P; p++)cin >> A[p];
	if (P == 2) {
		cout << A[0] << endl <<(A[0] + A[1]) % P << endl;
		return;
	}
	inv.resize(P);
	inv[0] = 0;
	for (int p = 1; p < P; p++) inv[p] = pow(p, P - 2, P);
	C.resize(P + 1);
	C[0] = 1, C[1] = P-1;
	for (int p = 2; p < P; p++) {
		C[p] = (C[p-1]*(P-p)*inv[p]) % P;
	}
	ans.resize(P, 0);
	if (A[0] == 1) {
		ans[P - 1] = P - 1;
		ans[0] = 1;
	}
	for(int n = 1;n < P;n++){
		if (A[n] == 0)continue;
		for (int k = 0; k < P; k++) {
			long long temp = C[k] * pow(P - n, P - 1 - k,P);
			temp %= P;
			ans[k] = (ans[k] +P - temp) % P;
		}
		ans[0]++;
		ans[0] %= P;
	}
	for (int i = 0; i < P; i++)cout << ans[i] << endl;
	return;
}
