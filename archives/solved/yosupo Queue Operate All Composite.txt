#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>
#include <list>

//< in.txt > out.txt
using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 998244353;//1e9 + 7;
typedef long long LL;
typedef long double LD;
typedef pair<LL, LL> PLL;
typedef pair<LD, LL> PDL;
typedef pair<LD, LD> PDD;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
//typedef boost::multiprecision::cpp_int bigint;

template<class T>
void in(T& x) {
	cin >> x;
}

template<class T1, class T2>
void in(pair<T1, T2>& p) {
	in(p.first);
	in(p.second);
}

template<class T>
void in(vector<T>& v, LL st = -1, LL en = -1) {
	if (st == -1) {
		st = 0;
		en = v.size() - 1;
	}
	for (LL n = st; n <= en; n++) {
		in(v[n]);
	}
}

class Ab {
public:
	LL a,b;
	Ab(LL _a,LL _b) :a(_a),b(_b) {};
	PLL operator()() {
		return PLL(a,b);
	}
	static Ab E;
	Ab() :a(1),b(0) {};
};
Ab Ab::E = Ab(1,0);
Ab operator+(Ab a, Ab b) {
	return Ab((a.a*b.a)%MOD,(a.b*b.a+b.b)%MOD);
}

//数列タイプのtreap
//Xorshift
unsigned int Xorshift() {
	static unsigned int tx = 123456789, ty = 362436069, tz = 521288629, tw = 88675123;
	unsigned int tt = (tx ^ (tx << 11));
	tx = ty; ty = tz; tz = tw;
	return (tw = (tw ^ (tw >> 19)) ^ (tt ^ (tt >> 8)));
}

struct node_t {
	Ab val;   //値
	node_t* ch[2];   //子
	LL pri;   //優先度
	LL cnt;   //子の個数
	Ab sum;   //値の和
	static LL node_count;   //プール用の要素を数える変数
	static const LL MAX_N = 4000000 + 10;   //プールのサイズ
	void* operator new(std::size_t) {
		static node_t pool[MAX_N];   //プール
		return pool + node_count++;
	}
	static void delete_all() {
		node_count = 0;
	}
	node_t(Ab v) {
		val = v;
		ch[0] = ch[1] = NULL;
		cnt = 1;
		sum = v;
		pri = Xorshift();
	}
	node_t() {
		val = Ab();
		ch[0] = ch[1] = NULL;
		cnt = 1;
		sum = val;
		pri = Xorshift();
	}
	node_t* update() {
		node_t* t = this;
		t->cnt = (t->ch[0] ? t->ch[0]->cnt : 0) + (t->ch[1] ? t->ch[1]->cnt : 0) + 1;
		t->sum = (t->ch[0] ? t->ch[0]->sum : Ab::E) + t->val;
		t->sum = t->sum + (t->ch[1] ? t->ch[1]->sum : Ab::E);
		return t;
	}
};
LL node_t::node_count = 0;


//2つのtreapをマージ
node_t* merge(node_t* l, node_t* r) {
	if (!l || !r)return !l ? r : l;
	if (l->pri > r->pri) {
		l->ch[1] = merge(l->ch[1], r);
		return l->update();
	}
	else {
		r->ch[0] = merge(l, r->ch[0]);
		return r->update();
	}
}

//treapを[0,k)と[k,n)にsplit
pair<node_t*, node_t*> split(node_t* t, LL k) {
	typedef pair<node_t*, node_t*> P;
	if (!t)return P(NULL, NULL);
	LL count = t->ch[0] ? t->ch[0]->cnt : 0;
	if (k <= count) {
		P s = split(t->ch[0], k);
		t->ch[0] = s.second;
		return P(s.first, t->update());
	}
	else {
		P s = split(t->ch[1], k - count - 1);
		t->ch[1] = s.first;
		return P(t->update(), s.second);
	}
}

//treap trの場所kに要素tを追加
node_t* insert(node_t* tr, LL k, node_t* t) {
	auto sp = split(tr, k);
	sp.first = merge(sp.first, t);
	return merge(sp.first, sp.second);
}

//treap trの場所kの要素を消去
node_t* erase(node_t* tr, LL k) {
	auto sp = split(tr, k - 1);
	auto sp2 = split(sp.second, 1);
	delete sp2.first;
	return merge(sp.first, sp2.second);
}

//void print(node_t* root) {
//	if (root == NULL)return;
//	print(root->ch[0]);
//	cout << " " << root->val();
//	print(root->ch[1]);
//	return;
//}

node_t* index(node_t* root, LL n) {
	if (!root)return NULL;
	LL ln = (root->ch[0] ? root->ch[0]->cnt : 0);
	LL rn = (root->ch[1] ? root->ch[1]->cnt : 0);
	if (n >= ln + rn)return NULL;
	if (n < ln)return index(root->ch[0], n);
	else if (n == ln)return root;
	else return index(root->ch[1], n - (ln + 1));
}

node_t* change(node_t* root, LL n, Ab x) {
	if (!root)return NULL;
	LL ln = (root->ch[0] ? root->ch[0]->cnt : 0);
	LL rn = (root->ch[1] ? root->ch[1]->cnt : 0);
	if (n >= ln + rn + 1)return NULL;
	if (n < ln) {
		node_t* r = change(root->ch[0], n, x);
		root->update();
		return r;
	}
	else if (n == ln) {
		root->val = x;
		root->update();
		return root;
	}
	else {
		node_t* r = change(root->ch[1], n - (ln + 1), x);
		root->update();
		return r;
	}
}

//[l,r]
Ab rangesum(node_t* root, LL l, LL r) {
	if (root == NULL)return Ab();
	LL ln = (root->ch[0] ? root->ch[0]->cnt : 0);
	LL rn = (root->ch[1] ? root->ch[1]->cnt : 0);
	if (r < 0 || l > ln + rn)return Ab();
	l = max((LL)0, l);
	r = min(ln + rn, r);
	if (l == 0 && r == ln + rn)return root->sum;
	Ab ans = rangesum(root->ch[0], l, r);
	if (l <= ln && ln <= r)ans = ans + root->val;
	ans = ans + rangesum(root->ch[1], l - ln - 1, r - ln - 1);
	return ans;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	LL Q;
	cin >> Q;
	node_t* tree = nullptr;
	for (LL q = 0; q < Q; q++) {
		LL t;
		cin >> t;
		if (t == 0) {
			LL a, b;
			cin >> a >> b;
			tree = merge(tree, new node_t(Ab(a, b)));
		}
		else if (t == 1) {
			auto temp = split(tree, 1);
			tree = temp.second;
		}
		else {
			LL x;
			cin >> x;
			if (tree == nullptr) {
				cout << x << "\n";
				continue;
			}
			PLL res = tree->sum();
			cout << (res.first * x + res.second) % MOD << "\n";
		}
	}
	return 0;
}

########################################
########################################
#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>
#include <list>

//< in.txt > out.txt
using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 998244353;//1e9 + 7;
typedef long long LL;
typedef long double LD;
typedef pair<LL, LL> PLL;
typedef pair<LD, LL> PDL;
typedef pair<LD, LD> PDD;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
//typedef boost::multiprecision::cpp_int bigint;

template<class T>
void in(T& x) {
	cin >> x;
}

template<class T1, class T2>
void in(pair<T1, T2>& p) {
	in(p.first);
	in(p.second);
}

template<class T>
void in(vector<T>& v, LL st = -1, LL en = -1) {
	if (st == -1) {
		st = 0;
		en = v.size() - 1;
	}
	for (LL n = st; n <= en; n++) {
		in(v[n]);
	}
}

class Modint {
public:
	LL v;
	Modint(LL _v) {
		_v %= MOD;
		if (_v < 0)_v += MOD;
		v = _v;
	}
	Modint operator+=(Modint m);
	Modint operator-=(Modint m);
	Modint operator*=(Modint m);
	friend ostream& operator<<(ostream& st, Modint m);
	friend ostream& operator>>(ostream& st, Modint m);
	Modint() :v(0) {}
};
ostream& operator<<(ostream& st, Modint m) {
	cout << m.v;
	return st;
}
ostream& operator>>(ostream& st, Modint m) {
	LL v;
	cin >> v;
	m.v = v % MOD;
	return st;
}
Modint operator+(Modint a, Modint b) {
	Modint r;
	r.v = a.v + b.v;
	if (r.v >= MOD)r.v -= MOD;
	return r;
}
Modint operator-(Modint a, Modint b) {
	Modint r;
	r.v = a.v - b.v;
	if (r.v < 0)r.v += MOD;
	return r;
}
Modint operator*(Modint a, Modint b) {
	return Modint((a.v * b.v) % MOD);
}
Modint operator+(Modint a, LL b) {
	return Modint(a.v + b);
}
Modint operator+(LL a, Modint b) {
	return Modint(a + b.v);
}
Modint operator-(Modint a, LL b) {
	return Modint(a.v - b);
}
Modint operator-(LL a, Modint b) {
	return Modint(a - b.v);
}
Modint operator*(Modint a, LL b) {
	return Modint(a.v * (b % MOD));
}
Modint operator*(LL a, Modint b) {
	return Modint((a % MOD) * b.v);
}
Modint Modint::operator+=(Modint m) {
	*this += *this + m;
	return *this;
}
Modint Modint::operator-=(Modint m) {
	*this = *this - m;
	return *this;
}
Modint Modint::operator*=(Modint m) {
	*this = *this * m;
	return *this;
}
template<class T>
T pow(T& base, LL p) {
	if (p == 0)return T();
	else if (p == 1)return base;
	T ret = pow(base, p / 2);
	ret *= ret;
	if (p & 1)ret *= base;
	return ret;
}

template<>
void in(Modint& m) {
	cin >> m.v;
}

template<class T>
class LinearFunction {
public:
	T a, b;
	LinearFunction(T _a, T _b) :a(_a), b(_b) {};
	T operator()(T x) {
		return a * x + b;
	}
};

//l(r(x))
template<class T>
LinearFunction<T> getlr(LinearFunction<T> l, LinearFunction<T> r) {
	return LinearFunction<T>(l.a * r.a, l.a * r.b + l.b);
}

//r(l(x))
template<class T>
LinearFunction<T> getrl(LinearFunction<T> l, LinearFunction<T> r) {
	return LinearFunction<T>(r.a * l.a, r.a * l.b + r.b);
}

template <class T>
class SlidingWindowAggregation {
private:
	stack<pair<T, T>> fr, ba;   //自分、和のペア
	T(*op)(T, T);   //関数ポインタ
public:
	SlidingWindowAggregation(T(*_op)(T, T)) :op(_op) {}
	LL GetSize() {
		return (LL)fr.size() + (LL)ba.size();
	}
	void push_back(T a) {
		if (ba.size() == 0)ba.push(pair<T, T>(a, a));
		else {
			pair<T, T> t = ba.top();
			pair<T, T> n(a, (*op)(t.second, a));
			ba.push(n);
		}
	}
	T pop_front() {
		if (fr.size() == 0) {
			while (ba.size() != 0) {
				T cur = ba.top().first;
				ba.pop();
				if (fr.size() == 0) {
					fr.push(pair<T, T>(cur, cur));
				}
				else {
					T prev = fr.top().second;
					fr.push(pair<T, T>(cur, (*op)(cur, prev)));
				}
			}
		}
		T ret = fr.top().first;
		fr.pop();
		return ret;
	}
	T Getall() {
		if (ba.size() == 0)return fr.top().second;
		if (fr.size() == 0)return ba.top().second;
		T frsum = fr.top().second;
		T basum = ba.top().second;
		return (*op)(frsum, basum);
	}
};

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	LL Q;
	cin >> Q;
	SlidingWindowAggregation<LinearFunction<Modint>> S(getrl<Modint>);
	for (LL q = 0; q < Q; q++) {
		LL t;
		cin >> t;
		if (t == 0) {
			LL a, b;
			cin >> a >> b;
			S.push_back(LinearFunction<Modint>(Modint(a), Modint(b)));
		}
		else if (t == 1) {
			S.pop_front();
		}
		else {
			LL x;
			cin >> x;
			if (S.GetSize() == 0) {
				cout << x << "\n";
			}
			else {
				LinearFunction<Modint> res = S.Getall();
				cout << res(Modint(x)) << "\n";
			}
		}
	}
	return 0;
}