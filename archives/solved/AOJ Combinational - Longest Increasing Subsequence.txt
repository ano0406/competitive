void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
#include <limits.h>
#include <math.h>
#include <iomanip>
#include <string>
using namespace std;
typedef pair<int, int> pii;
typedef long double ld;
typedef long long ll;

template<class T>
class segTree {
public:
	long long N;   //中身のある要素数
	long long RN;   //2の累乗数にするために合わせた、ゴミデータ含めた要素数
	vector<T>* array;
	T e;   //単位元
	function<T(T, T)> f;
	//コンストラクタ:要素数、初期化用の数
	segTree(long long n, T z,function<T(T,T)> F) {
		N = n;
		RN = 1;
		e = z;
		while (RN < N)RN *= 2;
		array = new vector<T>;
		array->resize(2 * RN - 1, e);
		f = F;
	}
	~segTree() {
		delete array;
	}
	void set(int n, T t) {   //n番目の要素にtを設定
		n = RN + n - 1;
		array->at(n) = t;
		while (n > 0) {
			n = (n - 1) / 2;
			array->at(n) = f(array->at(2 * n + 1) , array->at(2 * n + 2));
		}
	}
	inline T operator[](int a) {
		return array->at(RN + a - 1);
	}
	//[a,b)の和
	inline T get(int a, int b) {
		T vl = e, vr = e;
		for (int l = a + RN, r = b + RN; l < r; l >>= 1, r >>= 1) {
			if (l & 1) vl = f(vl , array->at((l++) - 1));
			if (r & 1) vr = f(array->at((--r) - 1) , vr);
		}
		return f(vl , vr);
	}
};

int N;
vector<int> temp;
vector<int> arr;

void solve() {
	cin >> N;
	temp.resize(N + 1);
	temp[0] = -1;
	arr.resize(N + 1);
	for (int n = 1; n <= N; n++) {
		cin >> temp[n];
		arr[n] = n;
	}
	segTree<int> T(N + 1, 0, [](int a, int b) {return max(a, b); });
	sort(arr.begin(), arr.end(), [](int a, int b) {
		if (temp[a] < temp[b])return true;
		else if (temp[a] > temp[b])return false;
		else if (a < b)return false;
		else return true;
	});
	for (int n = 1; n <= N; n++) {
		int a = T.get(0, arr[n]);
		T.set(arr[n], a+1);
	}
	cout << T.get(0, N + 1) << endl;
	return;
}