#include iostream
#include string
#include stack
#include vector
#include queue

using namespace std;

void solve();

int main() {
	solve();
	return 0;
}




class pos {
public
	int x, y;
	pos(int _x, int _y)x(_x),y(_y){}
	pos()x(0),y(0){}
};

int H, W;
int map[500][500];
bool bmap[500][500];
void bfs();
pos start, goal;

bool isIn(pos p) {
	if (p.x = 0 && p.x  W && p.y = 0 && p.y  H)return true;
	return false;
}

pos operator+(pos a,pos b) {
	return pos(a.x+b.x,a.y+b.y);
}

void solve() {
	cin  H  W;
	for (int y = 0; y  H; y++) {
		string s;
		cin  s;
		for(int x = 0;x  W;x++){
			if (s[x] == 's') {
				start = pos(x,y);
				map[x][y] = 500  500;
				bmap[x][y] = true;
			}
			else if (s[x] == 'g') {
				goal = pos(x,y);
				map[x][y] = 500  500;
				bmap[x][y] = true;
			}
			else if(s[x] == '.'){
				map[x][y] = 500  500;
				bmap[x][y] = true;
			}
			else {
				map[x][y] = 500500;
				bmap[x][y] = false;
			}
		}
	}
	bfs();
	if (map[goal.x][goal.y] = 2)cout  YES  endl;
	else cout  NO  endl;
	return;
}

typedef pairint, pos _pair;
bool operator(_pair a, _pair b) {
	return (a.first  b.first);
}

void bfs(){
	priority_queue_pair,vector_pair,greater_pair q;
	q.push(_pair(0,start));   開始地点のコストを0で初期化
	while (!q.empty()) {
		pos p = q.top().second;
		int cost = q.top().first;
		q.pop();
		if (map[p.x][p.y] = cost)continue;
		map[p.x][p.y] = cost;
		pos vecs[4] = {pos(1,0),pos(0,1),pos(-1,0),pos(0,-1)};
		for (int v = 0; v  4; v++) {
			pos n = p + vecs[v];
			if (!isIn(n))continue;
			if (!bmap[n.x][n.y])q.push(_pair(cost+1,n));
			else q.push(_pair(cost,n));
		}
	}
}