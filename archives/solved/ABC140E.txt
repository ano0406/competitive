#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
using namespace std;

//seg[n]にxを足す
void add(vector<int>& seg, int n, int x, int k = 1, int l = 0, int r = -1) {
	if (r == -1)r = seg.size() / 2 - 1;
	if (k == seg.size() / 2 + n)seg[k] += x;
	else if (l <= n && n <= r) {
		add(seg, n, x, 2 * k, l, (l + r) / 2);
		add(seg, n, x, 2 * k + 1, (l + r) / 2 + 1, r);
		seg[k] = seg[2 * k] + seg[2 * k + 1];
	}
}

//[a,b]の和
int get(vector<int>& seg, int a, int b, int k = 1, int l = 0, int r = -1) {
	if (r == -1)r = seg.size() / 2 - 1;
	if (b < l || r < a)return 0;
	if (a <= l && r <= b)return seg[k];
	return get(seg, a, b, 2 * k, l, (l + r) / 2) + get(seg, a, b, 2 * k + 1, (l + r) / 2 + 1, r);
}

void solve() {
	int N;
	vector<int> P;   //数字nがどこにあるか(1-index)
	vector<int> seg;
	cin >> N;
	int RN = 1;
	while (RN < N+2)RN *= 2;
	P.resize(N+2);
	seg.resize(RN * 2);
	for (int n = 1; n <= N; n++) {
		int a;
		cin >> a;
		P[a] = n;
	}
	long long ans = 0;
	add(seg, P[N], 1);
	add(seg, 0, 1);
	add(seg, N + 1, 1);
	for (int n = N - 1; n >= 1; n--) {
		//左右直近の自分より大きい数を探す
		int R, L;
		//seg[e]まで0 seg[s]から1
		int s = 0, e = P[n];
		while (e - s > 1) {
			int m = (e + s) / 2;
			if (get(seg, m, P[n]) > 0)s = m;
			else e = m;
		}
		L = s;
		//seg[s]まで0
		s = P[n], e = N+1;
		while (e - s > 1) {
			int m = (e + s) / 2;
			if (get(seg, P[n], m) == 0)s = m;
			else e = m;
		}
		R = e;
		int LL;
		if (L == 0)LL = 0;
		else {
			//seg[e]まで1
			s = 0, e = L;
			while (e - s > 1) {
				int m = (e + s) / 2;
				if (get(seg, m, P[n]) == 1)e = m;
				else s = m;
			}
			LL = s;
		}
		int RR;
		if (R == N + 1)RR = N+1;
		else {
			//seg[s]まで1
			s = R, e = N + 1;
			while (e - s > 1) {
				int m = (e + s) / 2;
				if (get(seg, P[n], m) == 1)s = m;
				else e = m;
			}
			RR = e;
		}
		int tmp = (L - LL) * (R - P[n]) + (P[n] - L) * (RR - R);
		ans += (long long)tmp * (long long)n;
		add(seg, P[n], 1);
	}
	cout << ans << endl;
	return;
}

//////////////////////////////
//////////////////////////////

int main() {
#ifdef DEBUGTIME
	for (int time = 0; time < DEBUGTIME; time++) {
		solve();
		cout << "####################" << endl;
	}
#else
	solve();
#endif
	return 0;
}
