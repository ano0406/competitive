void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <functional>
#include <map>
#include <string>
#include <boost/multiprecision/cpp_int.hpp>
#include <limits.h>
#include <iomanip>
#include <stack>

using namespace std;
using namespace boost::multiprecision;

//重み付きグラフ
//距離の部分をテンプレートに
template<class T>
class wGraph {
public:
	int N;
	vector<vector<pair<int,T>>>* E;
	wGraph(int n, T i) {
		N = n;
		E = new vector<vector<pair<int,T>>>;
		E->resize(N);
		INF = i;
	}
	wGraph() {
	}
	void constructor(int n, T i) {
		N = n;
		E = new vector<vector<pair<int, T>>>;
		E->resize(N);
		INF = i;
	}
	~wGraph() {
		delete E;
	}
	void addEdge(int a, int b, T c) {
		E->at(a).push_back(pair<int,T>(b,c));
	}
	T INF;
};

//負閉路検出(ベルマンフォード)
//O(E*V)
template<class T>
bool hasNegativeLoop(wGraph<T>& G) {
	vector<T>* d = new vector<T>;
	d->resize(G.N, G.INF);
	d->at(0) = 0;
	for (int i = 0; i < G.N; i++) {
		bool isRenewed = false;
		for (int from = 0; from < G.N; from++) {
			if (d->at(from) == G.INF)continue;
			for (auto itr = G.E->at(from).begin(); itr != G.E->at(from).end(); itr++) {
				if (d->at(itr->first) > d->at(from) + itr->second) {
					d->at(itr->first) = d->at(from) + itr->second;
					isRenewed = true;
					if (i == G.N - 1)return true;
				}
			}
		}
		if (!isRenewed) {
			delete d;
			return false;
		}
	}
	delete d;
	return false;
}

int N, M;
vector<int> P, Q, X, Y, A, B;

void solve() {
	cin >> N >> M;
	P.resize(N + 1);
	Q.resize(N + 1);
	X.resize(M + 1);
	Y.resize(M + 1);
	A.resize(M + 1);
	B.resize(M + 1);
	for (int n = 1; n <= N; n++)cin >> P[n];
	for (int n = 1; n <= N; n++)cin >> Q[n];
	for (int m = 1; m <= M; m++) cin >> X[m] >> Y[m] >> A[m] >> B[m];
	wGraph<long long> G(2 * N + 1, LLONG_MAX);
	for (int m = 1; m <= M; m++) {
		G.addEdge(X[m], Y[m] + N, -A[m]);
		G.addEdge(Y[m] + N, X[m], B[m]);
	}
	for (int n = 1; n <= N; n++) {
		G.addEdge(0, n, P[n]);
		G.addEdge(n, 0, 0);
		G.addEdge(n + N, 0, Q[n]);
		G.addEdge(0, n + N, 0);
	}
	bool res = hasNegativeLoop(G);
	cout << (res ? "no" : "yes") << endl;
	return;
}