#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>
#include <list>

//< in.txt > out.txt
using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 1e9 + 7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
typedef vector<ll> VLL;
typedef vector<VLL> VVLL;
//typedef boost::multiprecision::cpp_int bigint;

ll N, D, K;
VLL ans;
VLL pos;
VLL goal;
vector<pll> querys;

int main() {
	cin >> N >> D >> K;
	ans.resize(K);
	pos.resize(K);
	querys.resize(D+1);
	goal.resize(K);
	for (ll d = 1; d <= D; d++) {
		cin >> querys[d].first >> querys[d].second;
	}
	for(ll k = 0;k < K;k++){
		cin >> pos[k] >> goal[k];
	}
	for (ll d = 1; d <= D; d++) {
		ll L = querys[d].first;
		ll R = querys[d].second;
		for (ll k = 0; k < K; k++) {
			if (pos[k] == goal[k])continue;
			if (pos[k] < L || R < pos[k])continue;
			if (pos[k] < goal[k])pos[k] = min(R, goal[k]);
			else pos[k] = max(L, goal[k]);
			if (pos[k] == goal[k])ans[k] = d;
		}
	}
	for (ll k = 0; k < K; k++) {
		cout << ans[k] << "\n";
	}
	return 0;
}
