#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
using namespace std;

template<class T>
void in(vector<T>& V) {
	for (auto itr = V.begin(); itr != V.end(); itr++)cin >> *itr;
	return;
}

template<class T>
void out(vector<T>& V) {
	for (T& itr : V)cout << itr << endl;
	return;
}

//重みなしのグラフのクラス
class graph {
public:
	int N;
	vector<set<int>>* E;
	graph(int);
	graph();
	void construct(int);
	~graph();
	void addEdge(int, int);
	void removeEdge(int, int);
	bool isConnected(int, int);
};

graph::graph(int n) {
	construct(n);
}

graph::graph() {
	N = 0;
}

graph::~graph() {
	delete E;
}

void graph::construct(int n) {
	N = n;
	E = new vector<set<int>>;
	E->resize(N);
}

void graph::addEdge(int a, int b) {
	E->at(a).insert(b);
}

void graph::removeEdge(int a, int b) {
	auto itr = E->at(a).find(b);
	if (itr != E->at(a).end())E->at(a).erase(itr);
}

bool graph::isConnected(int a, int b) {
	return (E->at(a).find(b) != E->at(a).end());
}

void topologicalVisit(graph& g0, int n, vector<char>& check, stack<int>& q, bool& flag) {
	if (check.at(n) == 1) {
		flag = true;
		return;
	}
	if (check.at(n) == 0) {
		check.at(n) = 1;
		for (auto itr = g0.E->at(n).begin(); itr != g0.E->at(n).end(); itr++) {
			topologicalVisit(g0, *itr, check, q, flag);
			if (flag)return;
		}
		check[n] = 2;
		q.push(n);
	}
}

//与えられたグラフにトポロジカル順序?をつけたい
//(i->j => n(i) < n(j))
//グラフ、結果保存用空vector 木か木じゃないか返す
bool topologicalSort(graph& g0, vector<int>& deck) {
	vector<char>* check = new vector<char>;   //初期->0 一時的->1 恒久的-> 2
	check->resize(g0.N);
	for (int i = 0; i < g0.N; i++)check->at(i) = 0;

	stack<int>* qans = new stack<int>;
	bool cflag = false;
	for (int i = 0; i < g0.N; i++) {
		if (check->at(i) != 0)continue;
		topologicalVisit(g0, i, *check, *qans, cflag);
	}
	if (cflag)return false;
	while (!qans->empty()) {
		deck.push_back(qans->top());
		qans->pop();
	}
	delete qans;
	delete check;
	return true;
}

int N, M;

int main() {
	cin >> N >> M;
	graph G(N);
	graph Ginv(N);
	for (int m = 0; m < M; m++) {
		int x, y;
		cin >> x >> y;
		G.addEdge(--x, --y);
		Ginv.addEdge(y, x);
	}
	vector<int> topres;
	topologicalSort(G, topres);
	vector<int> DP;
	DP.resize(N, 0);
	for (int cur : topres) {
		for (int c : Ginv.E->at(cur)) {
			DP[cur] = max(DP[cur], DP[c] + 1);
		}
	}
	int ans = 0;
	for (int n = 0; n < N; n++)ans = max(ans, DP[n]);
	cout << ans << endl;
	return 0;
}