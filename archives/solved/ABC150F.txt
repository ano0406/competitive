#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>
#include <list>
#include <bitset>

//< in.txt > out.txt
using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 1e9 + 7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
typedef vector<ll> VLL;
typedef vector<VLL> VVLL;
typedef unsigned long long ull;
//typedef boost::multiprecision::cpp_int bigint;

vector<bool> check(ll N, VLL A, VLL B) {
	ull a = 0;
	for (ll n = 0; n < N; n++) {
		a = a * MOD + A[n];
	}
	ull t = 1;
	for (ll n = 0; n < N-1; n++)t *= MOD;
	vector<bool> flags(N, false);
	ull b = 0;
	for (ll n = 0; n < N; n++) {
		b = b*MOD + B[n];
	}
	for (ll n = 0; n < N; n++) {
		if (a == b)flags[n] = (flags[n] | true);
		a -= A[n] * t;
		a *= MOD;
		a += A[n + N];
	}
	b = 0;
	for (ll n = 0; n < N; n++) {
		b = b * MOD + (1-B[n]);
	}
	for (ll n = 0; n < N; n++) {
		if (a == b)flags[n] = (flags[n] | true);
		a -= A[n] * t;
		a *= MOD;
		a += A[n + N];
	}
	return flags;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	ll N;
	cin >> N;
	VLL A(2*N);
	VLL B(N);
	for (ll n = 0; n < N; n++) {
		cin >> A[n];
		A[N + n] = A[n];
	}
	for (ll n = 0; n < N; n++)cin >> B[n];
	vector<bool> flags(N, true);
	//各ビットごと
	for (ll b = 0; b < 30; b++) {
		VLL AA(2 * N);
		VLL BB(N);
		for (ll n = 0; n < N; n++) {
			AA[n] = ((ll)1 << b) & A[n];
			AA[N + n] = ((ll)1 << b) & A[N + n];
			BB[n] = ((ll)1 << b) & B[n];
			AA[n] = (AA[n] >> b);
			AA[N + n] = (AA[N + n] >> b);
			BB[n] = (BB[n] >> b);
		}
		vector<bool> res = check(N, AA, BB);
		for (ll n = 0; n < N; n++) {
			flags[n] = flags[n] & res[n];
		}
	}
	for (ll n = 0; n < N; n++) {
		if (flags[n]) {
			cout << n << " ";
			ll x = B[0] ^ A[n];
			cout << x << "\n";
		}
	}
	return 0;
}
##################################################
##################################################
#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>
#include <list>
#include <bitset>

//< in.txt > out.txt
using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 1e9 + 7;
typedef long long ll;
typedef long long LL;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
typedef vector<ll> VLL;
typedef vector<VLL> VVLL;
typedef unsigned long long ULL;
//typedef boost::multiprecision::cpp_int bigint;

typedef unsigned long long HASH;

class RollingHash {
public:
	static const ULL HMOD = (1ULL << 61) - 1;
	static const ULL MASK30 = (1ULL << 30) - 1;
	static const ULL MASK31 = (1ULL << 31) - 1;
	static ULL base;
	static const ULL POS = HMOD * ((1ULL<<3)-1);
	static vector<ULL> powmemo;
	vector<HASH> hash;   //部分列[0,n)のハッシュを持つ
	RollingHash(vector<LL>& S) {
		if (base == 0) {
			random_device rnd;
			mt19937 mt(rnd());
			uniform_int_distribution<ULL> rand(2, HMOD - 1);
			RollingHash::base = rand(mt);
			powmemo.resize(500000, 1);
			for (LL n = 1; n < 500000; n++) {
				powmemo[n] = mod(Mul(powmemo[n - 1], base));
			}
		}
		hash.resize(S.size() + 1);
		hash[0] = POS;
		for (ll n = 1; n <= S.size(); n++) {
			hash[n] = mod(Mul(hash[n - 1], base) + S[n-1]);
		}
	}
	//部分列[a,b)のハッシュ
	HASH get(LL a, LL b) {
		return mod(hash[b] + POS - Mul(hash[a], powmemo[b - a]));
	}
	//部分列配列への保存なしに変換
	HASH conv(vector<LL>& S) {
		HASH ans = 0;
		for (ll n = 0; n < S.size(); n++) {
			ans = mod(Mul(ans, base) + S[n]);
		}
		return ans;
	}
	static HASH Mul(HASH a, HASH b) {
		HASH au = a >> 31;
		HASH ad = a & MASK31;
		HASH bu = b >> 31;
		HASH bd = b & MASK31;
		HASH midd = au * bd + ad * bu;
		HASH midu = midd >> 30;
		midd = midd & MASK30;
		return au * bu * 2 + midu + midd * ((HASH)1 << 31) + ad * bd;
	}
	static HASH mod(HASH val) {
		val = (val & HMOD) + (val >> 61);
		if (val >= HMOD)val -= HMOD;
		return val;
	}
};
ULL RollingHash::base = 0;
vector<ULL> RollingHash::powmemo = vector<ULL>();

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	ll N;
	cin >> N;
	VLL A(2*N);
	VLL B(N);
	for (ll n = 0; n < N; n++) {
		cin >> A[n];
		A[N + n] = A[n];
	}
	for (ll n = 0; n < N; n++)cin >> B[n];
	vector<bool> flags(N, true);
	//各ビットごと
	for (ll b = 0; b < 30; b++) {
		VLL AA(2 * N);
		VLL BB(N);
		for (ll n = 0; n < N; n++) {
			AA[n] = ((ll)1 << b) & A[n];
			AA[N + n] = ((ll)1 << b) & A[N + n];
			BB[n] = ((ll)1 << b) & B[n];
			AA[n] = (AA[n] >> b);
			AA[N + n] = (AA[N + n] >> b);
			BB[n] = (BB[n] >> b);
		}
		RollingHash ah(AA);
		HASH bh = ah.conv(BB);
		vector<bool> res(N,false);
		for (ll n = 0; n < N; n++) {
			HASH x = ah.get(n, n + N);
			if (x == bh)res[n] = res[n] | true;
		}
		for (ll n = 0; n < N; n++)BB[n] = 1 - BB[n];
		bh = ah.conv(BB);
		for (ll n = 0; n < N; n++) {
			HASH x = ah.get(n, n + N);
			if (x == bh)res[n] = res[n] | true;
		}
		for (ll n = 0; n < N; n++) {
			flags[n] = flags[n] & res[n];
		}
	}
	for (ll n = 0; n < N; n++) {
		if (flags[n]) {
			cout << n << " ";
			ll x = B[0] ^ A[n];
			cout << x << "\n";
		}
	}
	return 0;
}
