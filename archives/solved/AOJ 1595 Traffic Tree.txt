#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>
#include <list>
#include <bitset>

//< in.txt > out.txt
using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 1e9 + 7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
typedef vector<ll> VLL;
typedef vector<VLL> VVLL;
//typedef boost::multiprecision::cpp_int bigint;

ll N;
VVLL edges;
VLL parents;
VVLL childs;

VLL DP0;
VLL DP1;

ll dp0(ll n) {
	if (DP0[n] != -1)return DP0[n];
	if (childs[n].size() == 0) {
		DP0[n] = 0;
		return DP0[n];
	}
	ll temp = 0;
	for (ll c : childs[n]) {
		temp = max(temp, dp0(c));
	}
	DP0[n] = temp + 1;
	return DP0[n];
}

void dp1(ll n) {
	if (n == 0) DP1[n] = 0;
	if (childs[n].size() == 0)return;
	VLL forward(childs[n].size());
	forward[0] = DP0[childs[n][0]];
	for (ll c = 1; c < childs[n].size(); c++) {
		forward[c] = max(forward[c - 1], DP0[childs[n][c]]);
	}
	VLL backward(childs[n].size());
	backward.back() = DP0[childs[n].back()];
	for (ll c = (ll)childs[n].size() - 2; c >= 0; c--) {
		backward[c] = max(backward[c + 1], DP0[childs[n][c]]);
	}
	for (ll c = 0; c < childs[n].size(); c++) {
		ll temp = 0;
		if (c > 0)temp = max(temp, forward[c - 1]+2);
		if (c < childs[n].size() - 1)temp = max(temp, backward[c + 1]+2);
		temp = max(temp, DP1[n]+1);
		DP1[childs[n][c]] = temp;
		dp1(childs[n][c]);
	}
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	cin >> N;
	parents.resize(N);
	childs.resize(N);
	edges.resize(N);
	for (ll n = 0; n < N - 1; n++) {
		ll s, t;
		cin >> s >> t;
		s--;
		t--;
		edges[s].push_back(t);
		edges[t].push_back(s);
	}
	queue<pll> q;
	q.push(pll(0, -1));
	while (!q.empty()) {
		ll cur = q.front().first;
		ll p = q.front().second;
		q.pop();
		parents[cur] = p;
		for (ll c : edges[cur]) {
			if (c == p)continue;
			childs[cur].push_back(c);
			q.push(pll(c, cur));
		}
	}
	DP0.resize(N,-1);
	dp0(0);
	DP1.resize(N, -1);
	dp1(0);
	for (ll n = 0; n < N; n++) {
		cout << 2*(N-1)-max(DP0[n], DP1[n]) << "\n";
	}
	return 0;
}