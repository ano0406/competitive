#include <iostream>
#include <string>
#include <stack>
#include <vector>
#include <queue>
#include <math.h>

using namespace std;

void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////

int N, M;
int start[15];
int d[14348907];
int goal1int, goal2int;

void bfs();

int arr2int(int arr[15]) {
	int sum = 0;
	for (int i = 0; i < N; i++)sum += arr[i] * pow(3,i);
	return sum;
}

void int2arr(int a,int* arr) {
	for (int i = 0; i < N; i++) {
		arr[i] = a % 3;
		a = (a - a % 3) / 3;
	}
}

void solve() {
	while (true) {
		cin >> N >> M;
		if (N == 0 && M == 0)return;
		for (int box = 0; box < 3; box++) {
			int n;
			cin >> n;
			for (int i = 0; i < n; i++) {
				int a;
				cin >> a;
				start[--a] = box;
			}
		}
		for (int i = 0; i < pow(3, N); i++)d[i] = -1;
		int goal1[15];
		for (int i = 0; i < 15; i++)goal1[i] = 0;
		goal1int = arr2int(goal1);
		int goal2[15];
		for (int i = 0; i < N; i++)goal2[i] = 2;
		for (int i = N; i < 15; i++)goal2[i] = 0;
		goal2int = arr2int(goal2);
		bfs();
		if (d[goal1int] == -1 || d[goal1int] > M) {
			if (d[goal2int] == -1 || d[goal2int] > M)cout << "-1" << endl;
			else cout << d[goal2int] << endl;
		}
		else {
			if (d[goal2int] == -1 || d[goal2int] > M)
				cout << d[goal1int] << endl;
			else cout << min(d[goal1int],d[goal2int]) << endl;
		}
	}
} 

typedef pair<int, int> _pair;
queue<_pair> q;   //ã«ñ ÅAâÒêî
int nowarr[15];
void bfs() {
	int startint = arr2int(start);
	q.push(_pair(startint,0));
	while (!q.empty()) {
		int nowint = q.front().first;
		int turn = q.front().second;
		q.pop();
		if (d[nowint] != -1 && d[nowint] <= turn)continue;
		if (turn >= M + 1)continue;
		d[nowint] = turn;
		if (nowint == goal1int || nowint == goal2int)return;
		int2arr(nowint,nowarr);
		if (nowarr[N - 1] == 1) {
			nowarr[N - 1] = 0;
			int a = arr2int(nowarr);
			if (d[a] == -1 || d[a] > turn + 1)q.push(_pair(a, turn + 1));
			nowarr[N - 1] = 2;
			a = arr2int(nowarr);
			if (d[a] == -1 || d[a] > turn + 1)q.push(_pair(a, turn + 1));
		}
		else {
			//ìÒî‘ñ⁄Ç…çÇÇ¢Ç∆Ç±ÇÎÇå©Ç¬ÇØÇÈ
			int sec;
			bool flag = false;
			for (sec = N - 1; sec >= 0; sec--) {
				if (nowarr[sec] != nowarr[N - 1]) {
					flag = true;
					break;
				}
			}
			if (nowarr[N - 1] == 0) {
				nowarr[N - 1] = 1;
				int a = arr2int(nowarr);
				if (d[a] == -1 || d[a] > turn + 1)q.push(_pair(a, turn + 1));
				if (!flag)continue;
				nowarr[N - 1] = 0;
				nowarr[sec] = 3 - nowarr[sec];
				a = arr2int(nowarr);
				if (d[a] == -1 || d[a] > turn + 1)q.push(_pair(a, turn + 1));
			}
			else {
				nowarr[N - 1] = 1;
				int a = arr2int(nowarr);
				if (d[a] == -1 || d[a] > turn + 1)q.push(_pair(a, turn + 1));
				if (!flag)continue;
				nowarr[N - 1] = 2;
				nowarr[sec] = 1 - nowarr[sec];
				a = arr2int(nowarr);
				if (d[a] == -1 || d[a] > turn + 1)q.push(_pair(a, turn + 1));
			}
		}
	}
	return;
}