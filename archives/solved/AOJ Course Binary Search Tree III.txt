#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>

using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 1e9 + 7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
typedef vector<ll> VLL;
typedef vector<VLL> VVLL;
//typedef boost::multiprecision::cpp_int bigint;

struct node {
	ll val;
	node* l;
	node* r;
	node* p;
	node(ll v,node* par) {
		val = v;
		l = NULL;
		r = NULL;
		p = par;
	}
};

void insert(node* T, ll x) {
	node* p = NULL;
	node* cur = T;
	while (cur != NULL) {
		p = cur;
		if (x < cur->val)cur = cur->l;
		else cur = cur->r;
	}
	if (x < p->val)p->l = new node(x,p);
	else p->r = new node(x,p);
	return;
}

node* find(node* T, ll x) {
	if (T == NULL)return NULL;
	if (T->val == x)return T;
	if (x < T->val)return find(T->l, x);
	else return find(T->r, x);
}

void erase(node* T, ll x) {
	if (T == NULL)return;
	if (T->val != x) {
		T = find(T,x);
		if (T->val != x)return;
	}
	if (T->l == NULL && T->r == NULL) {
		if (T->p != NULL) {
			if (T->p->l == T)T->p->l = NULL;
			else T->p->r = NULL;
		}
		delete T;
		return;
	}
	else if (T->l == NULL) {
		if (T->p == NULL) {
			auto oldt = T;
			T = T->r;
			delete oldt;
		}
		else {
			if (x < T->p->val) {
				T->p->l = T->r;
				T->r->p = T->p;
				delete T;
				return;
			}
			else {
				T->p->r = T->r;
				T->r->p = T->p;
				delete T;
				return;
			}
		}
	}
	else if (T->r == NULL) {
		if (T->p == NULL) {
			auto oldt = T;
			T = T->l;
			delete oldt;
		}
		else {
			if (T->p->l == T) {
				T->p->l = T->l;
				T->l->p = T->p;
				delete T;
				return;
			}
			else {
				T->p->r = T->l;
				T->l->p = T->p;
				delete T;
				return;
			}
		}
	}
	else {
		auto look = T->r;
		while (look->l != NULL)look = look->l;
		T->val = look->val;
		erase(look, look->val);
	}
	return;
}

void inoprint(node* t) {
	if (t == NULL)return;
	inoprint(t->l);
	cout << " " << t->val;
	inoprint(t->r);
	return;
}

void preoprint(node* t) {
	if (t == NULL)return;
	cout << " " << t->val;
	preoprint(t->l);
	preoprint(t->r);
	return;
}

void cleanup(node* T) {
	if (T == NULL)return;
	cleanup(T->l);
	cleanup(T->r);
	delete T;
	return;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	ll N;
	cin >> N;
	string ins;
	ll x;
	cin >> ins >> x;
	node* root = new node(x,NULL);
	for (ll n = 1; n < N; n++) {
		cin >> ins;
		if (ins[0] == 'i') {
			cin >> x;
			insert(root, x);
		}
		else if (ins[0] == 'f') {
			cin >> x;
			if (find(root, x))cout << "yes" << endl;
			else cout << "no" << endl;
		}
		else if (ins[0] == 'd') {
			cin >> x;
			erase(root, x);
		}
		else {
			inoprint(root);
			cout << "\n";
			preoprint(root);
			cout << "\n";
		}
	}
	cleanup(root);
	return 0;
}