#include <iostream>
#include <string>
#include <stack>
#include <vector>
#include <queue>

using namespace std;

void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////

class pos {
public:
	int x, y;
	pos(int _x, int _y):x(_x),y(_y){}
	pos():x(0),y(0){}
};

int H, W,N;
pos cheeses[10];   //チーズの場所、0はスタート位置
bool MAP[1000][1000];   //通れるならtrue

int bfs(int);   //番号nのチーズからn+1のチーズまでbfs

bool isIn(pos p) {
	if (p.x >= 0 && p.x < W && p.y >= 0 && p.y < H)return true;
	return false;
}

pos operator+(pos a,pos b) {
	return pos(a.x+b.x,a.y+b.y);
}

void solve() {
	cin >> H >> W >> N;
	for (int y = 0; y < H; y++) {
		string s;
		cin >> s;
		for (int x = 0; x < W; x++) {
			if (s[x] == 'X')MAP[x][y] = false;
			else if (s[x] == '.')MAP[x][y] = true;
			else if (s[x] == 'S') {
				cheeses[0] = pos(x, y);
				MAP[x][y] = true;
			}
			else {
				cheeses[s[x] - '1' + 1] = pos(x, y);
				MAP[x][y] = true;
			}
		}
	}
	int sum = 0;
	for (int n = 0; n < N; n++) {
		sum += bfs(n);
	}
	cout << sum << endl;
	return;
}

int map[1000][1000];
int bfs(int n) {
	for (int x = 0; x < W; x++) {
		for (int y = 0; y < H; y++) {
			if (MAP[x][y])map[x][y] = 1000 * 1000;   //通れるので
			else map[x][y] = -1;   //通れないので
		}
	}
	queue<pair<pos, int>> q;
	q.push(pair<pos,int>(cheeses[n],0));
	while (!q.empty()) {
		pos p = q.front().first;
		int d = q.front().second;
		q.pop();
		if (map[p.x][p.y] <= d)continue;
		map[p.x][p.y] = d;
		pos vecs[4] = {pos(1,0),pos(0,1),pos(-1,0),pos(0,-1)};
		for (int v = 0; v < 4; v++) {
			pos n = p + vecs[v];
			if (!isIn(n))continue;
			if (!MAP[n.x][n.y])continue;
			if (map[n.x][n.y] <= d + 1)continue;
			q.push(pair<pos,int>(n,d+1));
		}
	}
	return map[cheeses[n + 1].x][cheeses[n + 1].y];
}