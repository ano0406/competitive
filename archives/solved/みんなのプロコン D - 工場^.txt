#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
using namespace std;
long long MOD = 1e9 + 7;

//空vectorを要素数NのsegTreeとしてzで初期化
template<class T>
void segTree_init(vector<T>& vec, int N, T z) {
	int RN = 1;
	while (RN < N)RN *= 2;
	vec.resize(2 * RN, z);
}

//vecをsegTreeとしてn番目をxに
template<class T>
void segTree_set(vector<T>& vec, int n, T x, function<T(T, T)> f, int k = -1) {
	int RN = (vec.size() + 1) / 2;
	if (k == -1) {
		k = n + RN;
		vec[k] = x;
		segTree_set(vec, n, x, f, k / 2);
	}
	else if (k != 0) {
		vec[k] = f(vec[2 * k], vec[2 * k + 1]);
		segTree_set(vec, n, x, f, k / 2);
	}
}

//vecがsegTreeの時の、n番目の要素
template<class T>
T segTree_at(vector<T>& vec, int n) {
	int RN = (vec.size()) / 2;
	return vec[RN + n];
}

//get [a,b]
template<class T>
T segTree_get(vector<T>& vec, int a, int b, function<T(T, T)> f, T e, int k = 1, int l = 0, int r = -1) {
	if (r == -1)r = vec.size() / 2 - 1;
	if (b < l || r < a)return e;
	else if (a <= l && r <= b)return vec[k];
	else return f(
		segTree_get(vec, a, b, f, e, 2 * k, l, (l + r) / 2),
		segTree_get(vec, a, b, f, e, 2 * k + 1, (l + r) / 2 + 1, r)
	);
}

int Q, K;
map<int, int> dates;   //実日時がどの圧縮日時に対応するか
vector<int> datesv;
typedef pair<int, int> pii;
vector<pii> Querys;   //クエリ1->そのまま クエリ2->second = -1
vector<long long> ans;
typedef pair<int, long long> pil;
vector<pil> seg;

void setDates() {
	vector<int> V;
	V.push_back(0);
	V.push_back(1e9 + 1);
	for (int q = 0; q < Q; q++) {
		if (Querys[q].second == -1)continue;
		pii query = Querys[q];
		V.push_back(query.first);
	}
	sort(V.begin(), V.end(), [](int a, int b) {
		return a < b;
	});
	int c = 0;
	for (int d : V) {
		if (dates.find(d) == dates.end()) {
			dates.insert(pii(d,c));
			c++;
			datesv.push_back(d);
		}
	}
}

function<pil(pil, pil)> lambda = [](pil a, pil b) {
	if (b == pil(-1, -1))return pil(a.first, min(a.second, K * (long long)(a.first)));
	if (b.second <= K * (long long)b.first - min(K * (long long)a.first, a.second)) {
		return pil(b.first, b.second + min(K * (long long)a.first, a.second));
	}
	else {
		return pil(b.first, K * (long long)b.first);
	}
};

int main() {
	cin >> Q >> K;
	for (int q = 0; q < Q; q++) {
		int type;
		cin >> type;
		if (type == 1) {
			int d, a;
			cin >> d >> a;
			Querys.push_back(pii(d, a));
		}
		else {
			int d;
			cin >> d;
			Querys.push_back(pii(d, -1));
		}
	}
	setDates();
	segTree_init(seg, dates.size(), pil(0, 0));
	for (int d = 0; d < seg.size()/2; d++) {
		if (d < datesv.size() - 1)segTree_set(seg, d, pil(datesv[d], 0), lambda);
		else segTree_set(seg, d, pil(-1,-1), lambda);
	}
	for (pii query : Querys) {
		if (query.second != -1) {
			int d = dates.find(query.first)->second;
			long long before = segTree_at(seg, d).second;
			segTree_set(seg, d, pil(query.first,(long long)(before + query.second)), lambda);
		}
		else {
			int s = 0, e = datesv.size()-1;
			while (e - s > 1) {
				int m = (e + s) / 2;
				if (datesv[m] <= query.first)s = m;
				else e = m;
			}
			ans.push_back(segTree_get(seg,0,s,lambda,pil(-1,-1)).second);
		}
	}
	for (int e : ans) {
		cout << e << endl;
	}
	return 0;
}