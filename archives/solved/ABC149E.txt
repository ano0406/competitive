#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>
#include <list>

//< in.txt > out.txt
using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 1e9 + 7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
typedef vector<ll> VLL;
typedef vector<VLL> VVLL;
//typedef boost::multiprecision::cpp_int bigint;

ll N, M;
VLL A,AA;

ll judge(ll X) {
	ll ans = 0;
	for (ll n = 0; n < N; n++) {
		ll s = -1, e = N;
		while (e - s > 1) {
			ll m = (e + s) / 2;
			if (A[n] + A[m] >= X)s = m;
			else e = m;
		}
		ans += e;
	}
	return ans;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	cin >> N >> M;
	A.resize(N);
	for (ll n = 0; n < N; n++)cin >> A[n];
	sort(A.begin(), A.end(), [](ll a, ll b) {
		return a > b;
	});
	ll s = -1, e = 2 * (ll)1e5 * M+1;
	while (e - s > 1) {
		ll m = (e + s) / 2;
		if (judge(m) <= M)e = m;
		else s = m;
	}
	ll X = e;
	ll ans = 0;
	AA.resize(N);
	AA[0] = A[0];
	for (ll n = 1; n < N; n++) {
		AA[n] = AA[n - 1] + A[n];
	}
	ll cand = 0;
	for (ll n = 0; n < N; n++) {
		s = -1, e = N;
		while (e - s > 1) {
			ll m = (e + s) / 2;
			if (A[n] + A[m] >= X)s = m;
			else e = m;
		}
		ans += A[n] * e;
		if (e > 0)ans += AA[s];
		M -= e;
		if (e < N)cand = max(cand, A[n] + A[e]);
	}
	ans += M * cand;
	cout << ans << "\n";
	return 0;
}

########################################
########################################
//FFT解
//なんかWA出た
#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>
#include <list>

//< in.txt > out.txt
using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 1e9 + 7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
typedef vector<ll> VLL;
typedef vector<VLL> VVLL;
//typedef boost::multiprecision::cpp_int bigint;

using Complex = complex<double>;
const long double PI = 3.1415926535;

//DFT(離散Fouriet変換)
//A:変換したい多項式(A[i]=i次の係数)直変更!!!!!,N:1の何乗根?(2の累乗数),sgn:逆変換の時-1に
void dft(vector<Complex>* A, int N, int sgn = 1) {
	if (N == 1) return;

	vector<Complex>* F = new vector<Complex>(N / 2);
	vector<Complex>* G = new vector<Complex>(N / 2);
	for (int i = 0; i < N / 2; i++) {
		F->at(i) = A->at(2 * i + 0);
		G->at(i) = A->at(2 * i + 1);
	}

	dft(F, N / 2, sgn);
	dft(G, N / 2, sgn);

	Complex zeta(cos(2.0 * PI / N), sin(2.0 * PI / N) * sgn);
	Complex pow_zeta = 1;

	for (int i = 0; i < N; i++) {
		A->at(i) = F->at(i % (N / 2)) + pow_zeta * G->at(i % (N / 2));
		pow_zeta *= zeta;
	}
	delete F, G;
	return;
}

//inverse DFT(離散Fouriet逆変換)
//A:変換したい多項式,N:要素数(2の累乗数)
void inv_dft(vector<Complex>* A, int N) {
	dft(A, N, -1);
	for (int i = 0; i < N; i++) {
		A->at(i) /= N;
	}
	return;
}

//多項式の畳み込み(FFT,inverse FFTを使う)
//A,B:多項式(書き変わります...),C:結果保存用
void multiply(vector<Complex>& A, vector<Complex>& B, vector<Complex>& C) {
	int sz = A.size() + B.size() + 1;
	int n = 1;
	while (n < sz) n *= 2;

	A.resize(n), B.resize(n);
	dft(&A, n);
	dft(&B, n);

	C.resize(n);
	for (int i = 0; i < n; i++) {
		C[i] = A[i] * B[i];
	}
	inv_dft(&C, n);
	return;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	ll N,M;
	cin >> N >> M;
	vector<Complex> A(1e5+1,0);
	vector<Complex> B(1e5 + 1, 0);
	for (ll n = 0; n < N;n++) {
		ll a;
		cin >> a;
		A[a] += 1;
		B[a] += 1;
	}
	vector<Complex> C;
	multiply(A, B, C);
	ll ans = 0;
	for (ll c = 2e5; c >= 0; c--) {
		ll d = min((ll)round(C[c].real()), M);
		ans += d * c;
		M -= d;
	}
	cout << ans << "\n";
	return 0;
}