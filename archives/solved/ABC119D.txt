#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
using namespace std;
const long long MOD = 1e9+7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
//typedef boost::multiprecision::cpp_int bigint;

ll A, B, Q;
vector<ll> S, T;

ll solve(ll X) {
	//Sの中で挟めるやつ
	//S[e] > X >= S[s]
	ll ss = 0, se = A + 1;
	while (se - ss > 1) {
		ll m = (se + ss) / 2;
		if (X >= S[m])ss = m;
		else se = m;
	}
	ll ans = LLONG_MAX;
	//S[ss]に行った後どこに行くか考える
	ll ts = 0, te = B + 1;
	while (te - ts > 1) {
		ll m = (te + ts) / 2;
		if (T[m] > S[ss])te = m;
		else ts = m;
	}
	ans = min(ans, (X - S[ss]) + min(T[te] - S[ss], S[ss] - T[ts]));
	//S[se]に行った後どこに行くか考える
	ts = 0, te = B + 1;
	while (te - ts > 1) {
		ll m = (te + ts) / 2;
		if (T[m] > S[se])te = m;
		else ts = m;
	}
	ans = min(ans, (S[se]-X) + min(T[te] - S[se], S[se] - T[ts]));
	//Tの中で挟めるやつ
	//T[e] > X >= T[s]
	ts = 0, te = B + 1;
	while (te - ts > 1) {
		ll m = (te + ts) / 2;
		if (X >= T[m])ts = m;
		else te = m;
	}
	//S[ss]に行った後どこに行くか考える
	ss = 0, se = A + 1;
	while (se - ss > 1) {
		ll m = (se + ss) / 2;
		if (S[m] > T[ts])se = m;
		else ss = m;
	}
	ans = min(ans, (X - T[ts]) + min(S[se] - T[ts], T[ts] - S[ss]));
	//S[se]に行った後どこに行くか考える
	ss = 0, se = A + 1;
	while (se - ss > 1) {
		ll m = (se + ss) / 2;
		if (S[m] > T[te])se = m;
		else ss = m;
	}
	ans = min(ans, (T[te] - X) + min(S[se] - T[te], T[te] - S[ss]));
	return ans;
}

int main() {
	cin >> A >> B >> Q;
	S.resize(A + 2);
	T.resize(B + 2);
	S[0] = -1e10 - 1;
	for (ll n = 1; n <= A; n++)cin >> S[n];
	S[A + 1] = 2e10 + 1;
	T[0] = -1e10 - 1;
	for (ll b = 1; b <= B; b++)cin >> T[b];
	T[B + 1] = 2e10 + 1;
	sort(S.begin(), S.end(), [](ll a, ll b) {
		return a < b;
	});
	sort(T.begin(), T.end(), [](ll a, ll b) {
		return a < b;
	});
	for (ll q = 0; q < Q; q++) {
		ll X;
		cin >> X;
		cout << solve(X) << endl;
	}
	return 0;
}