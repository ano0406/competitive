void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <functional>
#include <map>
#include <string>
#include <boost/multiprecision/cpp_int.hpp>
#include <limits.h>
#include <iomanip>
#include <stack>

using namespace std;
using namespace boost::multiprecision;

template<class T>
class segTree {
public:
	int N;   //中身のある要素数
	int RN;   //2の累乗数にするために合わせた、ゴミデータ含めた要素数
	T* array;
	pair<int, int>* range;
	std::function<T(T, T)> f;
	//コンストラクタ:要素数、計算用ラムダ、初期化用の数
	segTree(int n, function<T(T, T)> F, T z) {
		N = n;
		RN = 1;
		while (RN < N)RN *= 2;
		array = new T[2 * RN];
		for (int i = 0; i < 2 * RN; i++)array[i] = z;
		range = new pair<int, int>[2 * RN];
		range[1] = pair<int, int>(0, RN);
		for (int i = 1; i < RN; i++) {
			range[2 * i] = pair<int, int>(range[i].first, (range[i].first + range[i].second) / 2);
			range[2 * i + 1] = pair<int, int>((range[i].first + range[i].second) / 2, range[i].second);
		}
		f = F;
	}
	~segTree() {
		delete array;
		delete range;
	}
	void set(int n, T t) {   //n番目の要素にtを設定
		n = RN + n;
		array[n] = t;
		while (n != 1) {
			n = n / 2;
			array[n] = f(array[2 * n], array[2 * n + 1]);
		}
	}
	T call(int l, int r, int id) {
		if (l == range[id].first && r == range[id].second)return array[id];
		int m = (range[id].first + range[id].second) / 2;
		if (r <= m)return call(l, r, 2 * id);
		if (m <= l)return call(l, r, 2 * id + 1);
		else if (l < m && m < r) {
			return f(call(l, m, 2 * id), call(m, r, 2 * id + 1));
		}
	}
	T get(int l, int r) {   //[a_l,a_r)
		return call(l, r, 1);
	}
	T operator[](int a) {
		return get(a, a + 1);
	}
};

int N, Q;
vector<int> ans;

void solve() {
	cin >> N >> Q;
	segTree<int> seg(N, [](int a, int b) {return min(a, b);},(int)pow(2,31)-1);
	for (int q = 0; q < Q; q++) {
		int c, x, y;
		cin >> c >> x >> y;
		if (c == 0) {
			seg.set(x, y);
		}
		else {
			ans.push_back(seg.get(min(x,y),max(x,y)+1));
		}
	}
	int i = 0;
	for (; i < ans.size()-1; i++)cout << ans[i] << endl;
	cout << ans[i];
	return;
}

########################################
########################################
#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>

using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 1e9 + 7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
typedef vector<ll> VLL;
typedef vector<VLL> VVLL;
//typedef boost::multiprecision::cpp_int bigint;

//数列タイプのtreap
//Xorshift
unsigned int Xorshift() {
	static unsigned int tx = 123456789, ty = 362436069, tz = 521288629, tw = 88675123;
	unsigned int tt = (tx ^ (tx << 11));
	tx = ty; ty = tz; tz = tw;
	return (tw = (tw ^ (tw >> 19)) ^ (tt ^ (tt >> 8)));
}

struct node_t {
	ll val;   //値
	node_t* ch[2];   //子
	ll pri;   //優先度
	ll cnt;   //子の個数
	ll sum;   //値の和
	static ll node_count;   //プール用の要素を数える変数
	static const ll MAX_N = 1000000 + 10;   //プールのサイズ
	/*void* operator new(std::size_t) {
		static node_t pool[MAX_N];   //プール
		return pool + node_count++;
	}*/
	/*static void delete_all() {
		node_count = 0;
	}*/
	node_t(ll v) {
		val = v;
		ch[0] = ch[1] = NULL;
		cnt = 1;
		sum = v;
		pri = Xorshift();
	}
	node_t() {}
	node_t* update() {
		node_t* t = this;
		t->cnt = (t->ch[0] ? t->ch[0]->cnt : 0) + (t->ch[1] ? t->ch[1]->cnt : 0) + 1;
		t->sum = min((t->ch[0] ? t->ch[0]->sum : LLONG_MAX),(t->ch[1] ? t->ch[1]->sum : LLONG_MAX));
		t->sum = min(t->sum, t->val);
		return t;
	}
};

void delete_all(node_t* root) {
	if (root == NULL)return;
	delete_all(root->ch[0]);
	delete_all(root->ch[1]);
	delete root;
	return;
}

//2つのtreapをマージ
node_t* merge(node_t* l, node_t* r) {
	if (!l || !r)return !l ? r : l;
	if (l->pri > r->pri) {
		l->ch[1] = merge(l->ch[1], r);
		return l->update();
	}
	else {
		r->ch[0] = merge(l, r->ch[0]);
		return r->update();
	}
}

//treapを[0,k)と[k,n)にsplit
pair<node_t*, node_t*> split(node_t* t, ll k) {
	typedef pair<node_t*, node_t*> P;
	if (!t)return P(NULL, NULL);
	ll count = t->ch[0] ? t->ch[0]->cnt : 0;
	if (k <= count) {
		P s = split(t->ch[0], k);
		t->ch[0] = s.second;
		return P(s.first, t->update());
	}
	else {
		P s = split(t->ch[1], k - count - 1);
		t->ch[1] = s.first;
		return P(t->update(), s.second);
	}
}

//treap trの場所kに要素tを追加
node_t* insert(node_t* tr, ll k, node_t* t) {
	auto sp = split(tr, k);
	sp.first = merge(sp.first, t);
	return merge(sp.first, sp.second);
}

//treap trの場所kの要素を消去
node_t* erase(node_t* tr, ll k) {
	auto sp = split(tr, k - 1);
	auto sp2 = split(sp.second, 1);
	delete sp2.first;
	return merge(sp.first, sp2.second);
}

void print(node_t* root) {
	if (root == NULL)return;
	print(root->ch[0]);
	cout << " " << root->val;
	print(root->ch[1]);
	return;
}

node_t* index(node_t* root,ll n) {
	if (!root)return NULL;
	ll ln = (root->ch[0] ? root->ch[0]->cnt : 0);
	ll rn = (root->ch[1] ? root->ch[1]->cnt : 0);
	if (n >= ln + rn)return NULL;
	if (n < ln)return index(root->ch[0], n);
	else if (n == ln)return root;
	else return index(root->ch[1], n - (ln + 1));
}

node_t* change(node_t* root, ll n, ll x) {
	if (!root)return NULL;
	ll ln = (root->ch[0] ? root->ch[0]->cnt : 0);
	ll rn = (root->ch[1] ? root->ch[1]->cnt : 0);
	if (n >= ln + rn + 1)return NULL;
	if (n < ln) {
		node_t* r = change(root->ch[0], n, x);
		root->update();
		return r;
	}
	else if (n == ln) {
		root->val = x;
		root->update();
		return root;
	}
	else {
		node_t* r = change(root->ch[1], n - (ln + 1), x);
		root->update();
		return r;
	}
}

ll rangesum(node_t* root, ll l, ll r) {
	if (root == NULL)return LLONG_MAX;
	ll ln = (root->ch[0] ? root->ch[0]->cnt : 0);
	ll rn = (root->ch[1] ? root->ch[1]->cnt : 0);
	if (r < 0 || l > ln + rn)return LLONG_MAX;
	l = max((ll)0, l);
	r = min(ln + rn, r);
	if (l == 0 && r == ln + rn)return root->sum;
	ll ans = rangesum(root->ch[0], l, r);
	if (l <= ln && ln <= r)ans = min(ans, root->val);
	ans = min(ans, rangesum(root->ch[1], l - ln - 1, r - ln - 1));
	return ans;
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	ll N, Q;
	cin >> N >> Q;
	node_t* root = NULL;
	for (ll n = 0; n < N; n++) {
		root = merge(root, new node_t(((ll)1 << 31) - 1));
	}
	ll c, x, y;
	for (ll q = 0; q < Q; q++) {
		cin >> c >> x >> y;
		if (c == 0) {
			change(root,x, y);
		}
		else {
			cout << rangesum(root, x, y) << "\n";
		}
	}
	return 0;
}