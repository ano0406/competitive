void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
using namespace std;

struct edge {
	int to;
	long long cost;
	long long timing;
};

vector<vector<edge>> Edges;
vector<long long> waiting;
priority_queue<pair<long long, int>,vector<pair<long long, int>>,greater<pair<long long, int>>> q;
vector<long long> dijkans;
long long N, M, K;

void solve() {
	cin >> N >> M >> K;
	Edges.resize(N);
	waiting.resize(N,0);
	dijkans.resize(N, LLONG_MAX);
	for (int n = 1; n < N - 1; n++)cin >> waiting[n];
	for (int m = 0; m < M; m++) {
		int a, b, c, d;
		cin >> a >> b >> c >> d;
		a--;
		b--;
		Edges[a].push_back({ b,c,d });
		Edges[b].push_back({ a,c,d });
	}
	q.push(pair<int, int>(0, 0));
	while (!q.empty()) {
		int curpos = q.top().second;
		long long curtime = q.top().first;
		q.pop();
		if (dijkans[curpos] < curtime)continue;
		dijkans[curpos] = curtime;
		curtime += waiting[curpos];
		for (auto itr = Edges[curpos].begin(); itr != Edges[curpos].end(); itr++) {
			if (curtime % itr->timing == 0)q.push(pair<long long, int>(curtime + itr->cost, itr->to));
			else q.push(pair<long long, int>(curtime - (curtime % itr->timing) + itr->timing + itr->cost, itr->to));
		}
	}
	if (dijkans[N - 1] >= K) {
		cout << -1 << endl;
	}
	else cout << dijkans[N - 1] << endl;
	return;
}
