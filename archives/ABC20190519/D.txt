void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <functional>
#include <map>
#include <string>
#include <boost/multiprecision/cpp_int.hpp>
#include <limits.h>
#include <iomanip>
#include <stack>

using namespace std;
using namespace boost::multiprecision;

//重みなしのグラフのクラス
class graph {
public:
	int N;
	vector<vector<int>>* E;
	graph(int);
	graph();
	void construct(int);
	~graph();
	void addEdge(int, int);
};

graph::graph(int n) {
	construct(n);
}

graph::graph() {
	N = 0;
}

graph::~graph() {
	delete E;
}

void graph::construct(int n) {
	N = n;
	E = new vector<vector<int>>;
	E->resize(N);
}

void graph::addEdge(int a, int b) {
	E->at(a).push_back(b);
}

vector<string> ans;
vector<vector<bool>> vmap;
int M, N, X0, Y0;
vector<int> dijkans;
queue<int> st;

bool isValid(int x, int y) {
	if (x < 0 || x >= M || y < 0 || y >= N)return false;
	return vmap[x][y];
}

int A(int x, int y) {
	return y * M + x;
}

int B(int x, int y) {
	return y * M + x + M * N;
}

int C(int x, int y) {
	return y * M + x + 2 * M * N;
}

void solve() {
	int T;
	cin >> T;
	for (; T > 0; T--) {
		cin >> N >> M >> X0 >> Y0;
		X0--; Y0--;
		vmap.clear();
		vmap.resize(M);
		graph G(3 * M*N);
		for (int x = 0; x < M; x++)vmap[x].resize(N);
		for (int y = 0; y < N; y++) {
			string S;
			cin >> S;
			for (int x = 0; x < M; x++)vmap[x][y] = (S[x] == '1');
		}
		for (int x = 0; x < M; x++) {
			for (int y = 0; y < N; y++) {
				if (!isValid(x, y))continue;
				if (isValid(x + 1, y) && isValid(x + 2, y)) {
					G.addEdge(A(x, y), B(x + 1, y));
					G.addEdge(B(x + 1, y), A(x, y));
				}
				if (isValid(x - 1, y) && isValid(x - 2, y)) {
					G.addEdge(A(x, y), B(x - 2, y));
					G.addEdge(B(x - 2, y), A(x, y));
				}
				if (isValid(x, y + 1) && isValid(x, y + 2)) {
					G.addEdge(A(x, y), C(x, y + 1));
					G.addEdge(C(x, y + 1), A(x, y));
				}
				if (isValid(x, y - 1) && isValid(x, y - 2)) {
					G.addEdge(A(x, y), C(x, y - 2));
					G.addEdge(C(x, y - 2), A(x, y));
				}
			}
		}
		for (int x = 0; x < M; x++) {
			for (int y = 0; y < N; y++) {
				if (!isValid(x, y) || !isValid(x + 1, y))continue;
				if (isValid(x, y + 1) && isValid(x + 1, y + 1)) {
					G.addEdge(B(x, y), B(x, y + 1));
					G.addEdge(B(x, y + 1), B(x, y));
				}
				if (isValid(x, y - 1) && isValid(x + 1, y - 1)) {
					G.addEdge(B(x, y), B(x, y - 1));
					G.addEdge(B(x, y - 1), B(x, y));
				}
			}
		}
		for (int x = 0; x < M; x++) {
			for (int y = 0; y < N; y++) {
				if (!isValid(x, y) || !isValid(x, y + 1))continue;
				if (isValid(x + 1, y) && isValid(x + 1, y + 1)) {
					G.addEdge(C(x, y), C(x + 1, y));
					G.addEdge(C(x + 1, y), C(x, y));
				}
				if (isValid(x - 1, y) && isValid(x - 1, y + 1)) {
					G.addEdge(C(x, y), C(x - 1, y));
					G.addEdge(C(x - 1, y), C(x, y));
				}
			}
		}
		dijkans.clear();
		dijkans.resize(3 * M*N);
		for (int i = 0; i < 3 * M*N; i++)dijkans[i] = INT_MAX;
		dijkans[A(X0, Y0)] = 0;
		st.push(A(X0,Y0));
		while (!st.empty()) {
			int cur = st.front();
			st.pop();
			for (auto itr = G.E->at(cur).begin(); itr != G.E->at(cur).end(); itr++) {
				if (dijkans[*itr] == INT_MAX) {
					dijkans[*itr] = dijkans[cur] + 1;
					st.push(*itr);
				}
			}
		}
		for (int y = 0; y < N; y++) {
			string temp("");
			if (dijkans[A(0, y)] == INT_MAX)temp += string("-1");
			else temp += to_string(dijkans[A(0, y)]);
			for (int x = 1; x < M; x++) {
				if (dijkans[A(x, y)] == INT_MAX)temp += string(" -1");
				else {
					temp += string(" ");
					temp += to_string(dijkans[A(x, y)]);
				}
			}
			ans.push_back(temp);
		}
	}
	for (int i = 0; i < ans.size(); i++) {
		cout << ans[i] << endl;
	}
	return;
}