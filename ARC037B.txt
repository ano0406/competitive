#include iostream
#include string
#include stack

using namespace std;

void solve();

int main() {
	solve();
	return 0;
}




int N, M;
bool isCon[100][100];    つながれてたらtrue
int ele[100];   tree番号

void solve() {
	cin  N  M;
	for (int i = 0; i  N; i++) {
		for (int j = 0; j  N; j++)isCon[i][j] = false;
	}
	for (int i = 0; i  M; i++) {
		int s, g;
		cin  s  g;
		isCon[--s][--g] = true;
		isCon[g][s] = true;
	}
	for (int i = 0; i  N; i++)ele[i] = -1;   -1初期化
	int sum = 0;
	int tree = 0;
	for (int s = 0; s  N; s++) {
		if (ele[s] != -1)continue;   既出だったら出る
		bool flag = false;   閉路フラグ
		stackint st;
		ele[s] = sum;
		st.push(s);
		while (!st.empty()) {
			int n = st.top();
			st.pop();
			for (int g = 0; g  N; g++) {   未使用の辺に沿って追加していく
				if (isCon[n][g]) {
					isCon[n][g] = false;
					isCon[g][n] = false;   使うのでfalse
					if (ele[g] != -1)flag = true;   つまり塗り済みっていうこと
					ele[g] = sum;
					st.push(g);
				}
			}
		}
		sum++;
		if (!flag)tree++;
	}
	cout  tree  endl;
}